/*
**  ComponentJS -- Component System for JavaScript <http://componentjs.com>
**  Copyright (c) 2009-2016 Ralf S. Engelschall <http://engelschall.com>
**
**  This Source Code Form is subject to the terms of the Mozilla Public
**  License (MPL), version 2.0. If a copy of the MPL was not distributed
**  with this file, You can obtain one at http://mozilla.org/MPL/2.0/.
*/
!function(GLOBAL,EXPORTS,DEFINE){/*
    **  GLOBAL LIBRARY NAMESPACING
    */
/*  internal API  */
var _cs=function(){},$cs=function(){/*  under run-time just pass through to lookup functionality  */
return _cs.hook("ComponentJS:lookup","pass",_cs.lookup.apply(GLOBAL,arguments))};/*  pattern sub-namespace  */
$cs.pattern={},/*  top-level API method: change symbol of external API  */
$cs.symbol=function(){/*  internal state  */
var a;a=void 0;var b=null;/*  top-level API method  */
return function(c){/*  return the global API  */
/*  release old occupation  */
/*  perform new occupation  */
/*  occupy no global slot at all  */
/*  occupy new global slot  */
return null!==b&&(GLOBAL[b]=a),"undefined"==typeof c||""===c?b=null:(b=c,a=GLOBAL[b],GLOBAL[b]=$cs),$cs}}(),/*  top-level API method: create a global namespace
        and optionally assign a value to the leaf object  */
$cs.ns=function(a,b){/*  sanity check name argument  */
if("string"!=typeof a||""===a)throw"invalid namespace path";/*  determine path  */
var c=a.split("."),d=c.length;"undefined"!=typeof b&&d--;for(/*  iterate over the path and create missing objects  */
var e=0,f=GLOBAL;e<d;)"undefined"==typeof f[c[e]]&&(f[c[e]]={}),f=f[c[e++]];/*  return the leaf object  */
/*  optionally assign a value to the leaf object  */
return"undefined"!=typeof b&&(f[c[e]]=b,f=b),f},/*  API version  */
$cs.version={major:1,minor:4,micro:3,date:20160816},/*
    **  COMMON UTILITY FUNCTIONALITIES
    */
/*  utility function: create an exception string for throwing  */
_cs.exception=function(a,b){var c;/*  return Error exception object  */
/*  optionally log stack trace to console  */
return $cs.debug()>0&&"object"==typeof GLOBAL.console&&("function"==typeof GLOBAL.console.trace?GLOBAL.console.trace():"undefined"!=typeof GLOBAL.printStackTrace&&"function"==typeof GLOBAL.console.log&&(c=GLOBAL.printStackTrace(),GLOBAL.console.log(c.join("\n")))),new Error("[ComponentJS]: ERROR: "+a+": "+b)},/*  utility function: logging via environment console  */
_cs.log=function(a){/*  try ComponentJS debugger  */
_cs.hook("ComponentJS:log","or",a)||("undefined"!=typeof GLOBAL.console&&"undefined"!=typeof GLOBAL.console.log?GLOBAL.console.log("[ComponentJS]: "+a):"undefined"!=typeof GLOBAL.Titanium&&"undefined"!=typeof GLOBAL.Titanium.API&&"function"==typeof GLOBAL.Titanium.API.log&&GLOBAL.Titanium.API.log("[ComponentJS]: "+a))},/*  utility function: debugging  */
$cs.debug=function(){var a=0;return function(b,c){if(0===arguments.length)/*  return old debug level  */
return a;if(1===arguments.length)/*  configure new debug level  */
a=b;else/*  perform runtime logging  */
if(b<=a){for(var d="",e=1;e<b;e++)d+="    ";/*  display debug message  */
_cs.log("DEBUG["+b+"]: "+d+c)}}}(),/*  utility function: no operation (for passing as dummy callback)  */
_cs.nop=function(){},/*  utility function: annotate an object  */
_cs.annotation=function(a,b,c){var d=null,e="__ComponentJS_"+b+"__";/*  get annotation value  */
/*  set annotation value  */
return"undefined"!=typeof a&&null!==a&&("undefined"!=typeof a[e]&&(d=a[e]),"undefined"!=typeof c&&(null!==c?a[e]=c:delete a[e])),d},/*  utility function: conveniently check for defined variable  */
_cs.isdefined=function(a){return"undefined"!=typeof a},/*  utility function: check whether a field is directly owned by object
        (instead of implicitly resolved through the constructor's prototype object)  */
_cs.isown=function(a,b){var c=Object.hasOwnProperty.call(a,b);return"constructor"!==b&&"prototype"!==b||(c=c&&Object.propertyIsEnumerable.call(a,b),a[b].toString().indexOf("[native code]")!==-1&&(c=!1)),c},/*  utility function: determine type of anything,
        an improved version of the built-in "typeof" operator  */
_cs.istypeof=function(a){var b=typeof a;/*  JavaScript nasty special case: null object  */
/*  JavaScript nasty special case: String object  */
/*  JavaScript nasty special case: Number object  */
/*  JavaScript nasty special case: Boolean object  */
/*  JavaScript nasty special case: Function object  */
/*  JavaScript nasty special case: Array object  */
/*  ComponentJS special case: "component"  */
return"object"===b?null===a?b="null":"[object String]"===Object.prototype.toString.call(a)?b="string":"[object Number]"===Object.prototype.toString.call(a)?b="number":"[object Boolean]"===Object.prototype.toString.call(a)?b="boolean":"[object Function]"===Object.prototype.toString.call(a)?b="function":"[object Array]"===Object.prototype.toString.call(a)?b="array":null!==_cs.annotation(a,"type")&&(b=_cs.annotation(a,"type")):"function"===b&&null!==_cs.annotation(a,"type")&&(b=_cs.annotation(a,"type")),b},/*  utility function: retrieve keys of object  */
_cs.keysof=function(a){var b=[];for(var c in a)_cs.isown(a,c)&&b.push(c);return b},/*  utility function: JSON encoding of object  */
_cs.json=function(){var a=/[\\\"\x00-\x1f\x7f-\x9f\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g,b={"\b":"\\b","\t":"\\t","\n":"\\n","\f":"\\f","\r":"\\r",'"':'\\"',"\\":"\\\\"},c=function(c){return a.lastIndex=0,a.test(c)?'"'+c.replace(a,function(a){var c=b[a];return"string"==typeof c?c:"\\u"+("0000"+a.charCodeAt(0).toString(16)).slice(-4)})+'"':'"'+c+'"'},d=function(a,b){if("boolean"!=typeof a&&"number"!=typeof a&&"string"!=typeof a){if("undefined"!=typeof b[a])return"null /* CYCLE! */";b[a]=!0}switch(typeof a){case"boolean":a=String(a);break;case"number":a=isFinite(a)?String(a):"NaN";break;case"string":a=c(a);break;case"function":a=null!==_cs.annotation(a,"type")?"<"+_cs.annotation(a,"type")+">":"<function>";break;case"object":var d=[];if(null===a)a="null";else if(null!==_cs.annotation(a,"type"))a="<"+_cs.annotation(a,"type")+">";else if("[object Function]"===Object.prototype.toString.call(a))a="<function>";else if("[object Array]"===Object.prototype.toString.call(a)||a instanceof Array){for(var e=0;e<a.length;e++)d[e]=arguments.callee(a[e],b);/* RECURSION */
a=0===d.length?"[]":"["+d.join(",")+"]"}else{for(var f in a)if(Object.hasOwnProperty.call(a,f)){var g=arguments.callee(a[f],b);/* RECURSION */
d.push(c(f)+":"+g)}a=0===d.length?"{}":"{"+d.join(",")+"}"}break;default:a="<unknown>"}return a};return function(a){return d(a,{})}}(),/*  utility function: deep cloning of arbitrary data-structure  */
_cs.clone=function(a,b){/*  allow recursive cloning to be controlled  */
if("undefined"==typeof b)b=function(){return!0};else if("string"==typeof b){var c=b;b=function(a){return a.match(c)}}/*  helper functions  */
var d,e=arguments.callee,f=function(a,b){/* eslint no-unused-vars: 0 */
var c=function(){return a.apply(this,arguments)};c.prototype=a.prototype;for(var d in a)_cs.isown(a,d)&&(b(d,a)?c[d]=e(a[d],b):c[d]=a[d]);return _cs.annotation(c,"clone",!0),c};if(d=void 0,"function"==typeof a)/*  special case: primitive function  */
d=f(a,b);else if("object"==typeof a)if(null===a)/*  special case: null object  */
d=null;else if("[object String]"===Object.prototype.toString.call(a))/*  special case: String object  */
d=""+a.valueOf();else if("[object Number]"===Object.prototype.toString.call(a))/*  special case: Number object  */
d=0+a.valueOf();else if("[object Boolean]"===Object.prototype.toString.call(a))/*  special case: Boolean object  */
d=!!a.valueOf();else if("[object Function]"===Object.prototype.toString.call(a))/*  special case: Function object  */
d=f(a,b);else if("[object Date]"===Object.prototype.toString.call(a))/*  special case: Date object  */
d=new Date(a.getTime());else if("[object RegExp]"===Object.prototype.toString.call(a))/*  special case: RegExp object  */
d=new RegExp(a.source);else if("[object Array]"===Object.prototype.toString.call(a)){/*  special case: array object  */
var g=a.length;d=[];for(var h=0;h<g;h++)d.push(e(a[h],b))}else{/*  special case: hash object  */
d={};for(var i in a)"constructor"!==i&&_cs.isown(a,i)&&(b(i,a)?d[i]=e(a[i],b):d[i]=a[i]);"function"==typeof a.constructor&&(d.constructor=a.constructor),"object"==typeof a.prototype&&(d.prototype=a.prototype)}else/*  regular case: anything else
                (just primitive data types and undefined value)  */
d=a;return d},/*  utility function: extend an object with other object(s)  */
_cs.extend=function(a,b,c){if("undefined"==typeof c)c=function(){return!0};else if("string"==typeof c){var d=c;c=function(a){return a.match(d)}}for(var e in b)_cs.isown(b,e)&&c(e,b[e])&&(a[e]=b[e]);return a},/*  utility function: mixin objects into another object by chaining methods  */
_cs.mixin=function(a,b,c){if("undefined"==typeof c)c=function(){return!0};else if("string"==typeof c){var d=c;c=function(a){return a.match(d)}}for(var e in b)if(_cs.isown(b,e)&&c(e,b[e]))if("function"===_cs.istypeof(b[e])){/*  method/function  */
var f=_cs.clone(b[e],c);_cs.annotation(f,"name",e),"function"===_cs.istypeof(a[e])&&_cs.isown(a,e)&&_cs.annotation(f,"base",a[e]),a[e]=f}else/*  property/field  */
a[e]=b[e];return a},/*  utility function: concatenate array values  */
_cs.concat=function(){for(var a=[],b=0;b<arguments.length;b++)for(var c=arguments[b],d=0;d<c.length;d++)a.push(c[d]);return a},/*  utility function: slice array values  */
_cs.slice=function(a,b,c){var d=[];"undefined"==typeof c&&(c=a.length);for(var e=b;e<c;e++)d.push(a[e]);return d},/*  utility function: map array values  */
_cs.map=function(a,b){for(var c=[],d=0;d<a.length;d++)c.push(b(a[d],d));return c},/*  utility function: filter array values  */
_cs.filter=function(a,b){for(var c=[],d=0;d<a.length;d++)b(a[d],d)&&c.push(a[d]);return c},/*  utility function: iterate over values  */
_cs.foreach=function(a,b){for(var c=0;c<a.length;c++)b(a[c],c)},/*  custom Token class  */
_cs.token=function(){this.name="",this.text="",this.tokens=[],this.pos=0,this.len=0},_cs.token.prototype={/*  setter for caller context name  */
setName:function(a){this.name=a},/*  setter for plain-text input  */
setText:function(a){this.text=a},/*  setter for additional token symbols  */
addToken:function(a,b,c,d,e){this.tokens.push({b1:a,b2:b,e2:c,e1:d,symbol:e}),this.len++},/*  peek at the next token or token at particular offset  */
peek:function(a){if("undefined"==typeof a&&(a=0),a>=this.len)throw _cs.exception(this.name,"parse error: not enough tokens");return this.tokens[this.pos+a].symbol},/*  skip one or more tokens  */
skip:function(a){if("undefined"==typeof a&&(a=1),a>this.len)throw _cs.exception(this.name,"parse error: not enough tokens available to skip: "+this.ctx());this.pos+=a,this.len-=a},/*  consume the current token (by expecting it to be a particular symbol)  */
consume:function(a){if(this.len<=0)throw _cs.exception(this.name,"parse error: no more tokens available to consume: "+this.ctx());if(this.tokens[this.pos].symbol!==a)throw _cs.exception(this.name,'parse error: expected token symbol "'+a+'": '+this.ctx());this.pos++,this.len--},/*  return a textual description of the token parsing context  */
ctx:function(a){"undefined"==typeof a&&(a=78);var b=this.tokens[this.pos],c="<"+this.text.substr(b.b2,b.e2-b.b2+1)+">";c=this.text.substr(b.b1,b.b2-b.b1)+c,c+=this.text.substr(b.e2+1,b.e1-b.e2);/*  the previous and following token(s)  */
var d=a-c.length;if(d>0){d=Math.floor(d/2);var e,f;if(this.pos>0){/*  previous token(s)  */
var g=0;for(e=this.pos-1;e>=0&&(b=this.tokens[e],f=this.text.substr(b.b1,b.e1-b.b1+1),g+=f.length,!(g>d));e--)c=f+c;e>0&&(c="[...]"+c)}if(this.len>1){/*  following token(s)  */
var h=0;for(e=this.pos+1;e<this.pos+this.len&&(b=this.tokens[e],f=this.text.substr(b.b1,b.e1-b.b1+1),h+=f.length,!(h>d));e++)c+=f;e<this.pos+this.len&&(c+="[...]")}}/*  place everything on a single line through escape sequences  */
return c=c.replace(/\r/,"\\r").replace(/\n/,"\\n").replace(/\t/,"\\t")}},/*  API function: validate an arbitrary value  */
$cs.validate=function(a,b){/*  case 1: specification is a regular expression object  */
if("object"==typeof b&&b instanceof RegExp)return b.test(a.toString());if("function"==typeof b)return b(a);if("string"==typeof b)return _cs.validate_at(a,b);throw _cs.exception("validate",'invalid specification argument: "'+b+'"')},/*  internal: validate an arbitrary value against a type specification  */
_cs.validate_at=function(a,b,c){/*  compile validation AST from specification
            or reuse cached pre-compiled validation AST  */
var d=_cs.validate_cache[b];/*  optionally subset the AST  */
if("undefined"==typeof d&&(d=_cs.validate_compile(b),_cs.validate_cache[b]=d),"undefined"!=typeof c){var e="string"==typeof c?_cs.select_parse(c):c;d=_cs.validate_subset(d,e)}/*  execute validation AST against the value  */
return _cs.validate_executor.exec_spec(a,d)},/*  the internal compile cache  */
_cs.validate_cache={},/*
     *  VALIDATION SPECIFICATION COMPILER
     */
/*  compile validation specification into validation AST  */
_cs.validate_compile=function(a){/*  tokenize the specification string into a token stream */
var b=_cs.validate_tokenize(a);/*  parse the token stream into an AST  */
return _cs.validate_parser.parse_spec(b)},/*  tokenize the validation specification  */
_cs.validate_tokenize=function(a){/*  create new Token abstraction  */
var b=new _cs.token;b.setName("validate"),b.setText(a);for(/*  determine individual token symbols  */
var c,d=0;""!==a;){if(c=a.match(/^(\s*)([^{}\[\]:,?*+()!|\s]+|[{}\[\]:,?*+()!|])(\s*)/),null===c)throw _cs.exception("validate",'parse error: cannot further canonicalize: "'+a+'"');b.addToken(d,d+c[1].length,d+c[1].length+c[2].length-1,d+c[0].length-1,c[2]),a=a.substr(c[0].length),d+=c[0].length}return b},/*  parse specification  */
_cs.validate_parser={parse_spec:function(a){if(a.len<=0)return null;var b,c=a.peek();if("!"===c)b=this.parse_not(a);else if("("===c)b=this.parse_group(a);else if("{"===c)b=this.parse_hash(a);else if("["===c)b=this.parse_array(a);else if(c.match(/^(?:null|undefined|boolean|number|string|function|object)$/))b=this.parse_primary(a);else if(c.match(/^(?:clazz|trait|component)$/))b=this.parse_special(a);else if("any"===c)b=this.parse_any(a);else{if(!c.match(/^[A-Z][_a-zA-Z$0-9]*$/))throw _cs.exception("validate",'parse error: invalid token symbol: "'+a.ctx()+'"');b=this.parse_class(a)}return b},/*  parse boolean "not" operation  */
parse_not:function(a){a.consume("!");var b=this.parse_spec(a);/*  RECURSION  */
return b={type:"not",op:b}},/*  parse group (for boolean "or" operation)  */
parse_group:function(a){a.consume("(");for(var b=this.parse_spec(a);"|"===a.peek();){a.consume("|");var c=this.parse_spec(a);/*  RECURSION  */
b={type:"or",op1:b,op2:c}}return a.consume(")"),b},/*  parse hash type specification  */
parse_hash:function(a){a.consume("{");for(var b=[];"}"!==a.peek();){var c=this.parse_key(a),d=this.parse_arity(a,"?");a.consume(":");var e=this.parse_spec(a);if(/*  RECURSION  */
b.push({type:"element",key:c,arity:d,element:e}),","!==a.peek())break;a.skip()}var f={type:"hash",elements:b};return a.consume("}"),f},/*  parse array type specification  */
parse_array:function(a){a.consume("[");for(var b=[];"]"!==a.peek();){var c=this.parse_spec(a),d=this.parse_arity(a,"?*+");if(b.push({type:"element",element:c,arity:d}),","!==a.peek())break;a.skip()}var e={type:"array",elements:b};return a.consume("]"),e},/*  parse primary type specification  */
parse_primary:function(a){var b=a.peek();if(!b.match(/^(?:null|undefined|boolean|number|string|function|object)$/))throw _cs.exception("validate",'parse error: invalid primary type "'+b+'"');return a.skip(),{type:"primary",name:b}},/*  parse special ComponentJS type specification  */
parse_special:function(a){var b=a.peek();if(!b.match(/^(?:clazz|trait|component)$/))throw _cs.exception("validate",'parse error: invalid special type "'+b+'"');return a.skip(),{type:"special",name:b}},/*  parse special "any" type specification  */
parse_any:function(a){var b=a.peek();if("any"!==b)throw _cs.exception("validate",'parse error: invalid any type "'+b+'"');return a.skip(),{type:"any"}},/*  parse JavaScript class specification  */
parse_class:function(a){var b=a.peek();if(!b.match(/^[A-Z][_a-zA-Z$0-9]*$/))throw _cs.exception("validate",'parse error: invalid class type "'+b+'"');return a.skip(),{type:"class",name:b}},/*  parse arity specification  */
parse_arity:function(a,b){var c=[1,1];if(a.len>=5&&"{"===a.peek(0)&&a.peek(1).match(/^[0-9]+$/)&&","===a.peek(2)&&a.peek(3).match(/^(?:[0-9]+|oo)$/)&&"}"===a.peek(4))c=[parseInt(a.peek(1),10),"oo"===a.peek(3)?Number.MAX_VALUE:parseInt(a.peek(3),10)],a.skip(5);else if(a.len>=1&&1===a.peek().length&&b.indexOf(a.peek())>=0){var d=a.peek();switch(d){case"?":c=[0,1];break;case"*":c=[0,Number.MAX_VALUE];break;case"+":c=[1,Number.MAX_VALUE]}a.skip()}return c},/*  parse hash key specification  */
parse_key:function(a){var b=a.peek();if(!b.match(/^(?:[_a-zA-Z$][_a-zA-Z$0-9]*|@)$/))throw _cs.exception("validate",'parse error: invalid key "'+b+'"');return a.skip(),b}},/*
     *  VALIDATION AST SUB-SETTING
     */
/*  subset an AST through a path of dereferencing steps  */
_cs.validate_subset=function(a,b){var c,d,e,f;for(c=0,d=b.length;c<d;c++)if("hash"===a.type){var g=!1;for(e=0,f=a.elements.length;e<f;e++){if(a.elements[e].key===b[c]){a=a.elements[e].element,g=!0;break}"@"===a.elements[e].key&&(a=a.elements[e].element,g=!0)}if(!g)throw _cs.exception("validate",'dereference error: hash key "'+b[c]+'" not found')}else{if("array"!==a.type)throw _cs.exception("validate",'dereference error: no more hash or array to be dereferenced by "'+b[c]+'"');if(e=parseInt(b[c],10),e>=a.elements.length)throw _cs.exception("validate","dereference error: array index #"+e+' ("'+b[c]+'") not found');a=a.elements[e].element}return a},/*
     *  VALIDATION AST EXECUTOR
     */
_cs.validate_executor={/*  validate specification (top-level)  */
exec_spec:function(a,b){var c=!1;if(null!==b)switch(b.type){case"not":c=this.exec_not(a,b);break;case"or":c=this.exec_or(a,b);break;case"hash":c=this.exec_hash(a,b);break;case"array":c=this.exec_array(a,b);break;case"primary":c=this.exec_primary(a,b);break;case"special":c=this.exec_special(a,b);break;case"class":c=this.exec_class(a,b);break;case"any":c=!0;break;default:throw _cs.exception("validate",'invalid validation AST: node has unknown type "'+b.type+'"')}return c},/*  validate through boolean "not" operation  */
exec_not:function(a,b){return!this.exec_spec(a,b.op)},/*  validate through boolean "or" operation  */
exec_or:function(a,b){return this.exec_spec(a,b.op1)||this.exec_spec(a,b.op2)},/*  validate hash type  */
exec_hash:function(a,b){var c,d,e="object"==typeof a,f={};if(e)/*  pass 1: ensure that all mandatory fields exist
                    and determine map of valid fields for pass 2  */
for(c=0;c<b.elements.length;c++)if(d=b.elements[c],f[d.key]=d.element,d.arity[0]>0&&("@"===d.key&&0===_cs.keysof(a).length||"@"!==d.key&&"undefined"==typeof a[d.key])){e=!1;break}if(e)/*  pass 2: ensure that no unknown fields exist
                    and that all existing fields are valid  */
for(var g in a)if(Object.hasOwnProperty.call(a,g)&&Object.propertyIsEnumerable.call(a,g)&&"constructor"!==g&&"prototype"!==g&&!("undefined"!=typeof f[g]&&this.exec_spec(a[g],f[g])||"undefined"!=typeof f["@"]&&this.exec_spec(a[g],f["@"]))){e=!1;break}return e},/*  validate array type  */
exec_array:function(a,b){var c,d,e="object"==typeof a&&a instanceof Array;if(e){var f=0;for(c=0;c<b.elements.length;c++){d=b.elements[c];for(var g=0;g<d.arity[1]&&f<a.length&&this.exec_spec(a[f],d.element);)g++,f++;if(g<d.arity[0]){e=!1;break}}f<a.length&&(e=!1)}return e},/*  validate standard JavaScript type  */
exec_primary:function(a,b){return"null"===b.name&&null===a||typeof a===b.name},/*  validate custom JavaScript type  */
exec_class:function(value,node){/* jshint evil:true */
/* eslint no-eval: 0 */
return"object"==typeof value&&Object.prototype.toString.call(value)==="[object "+node.name+"]"||eval("value instanceof "+node.name)},/*  validate special ComponentJS type  */
exec_special:function(a,b){var c=!1;return typeof a==("component"===b.name?"object":"function")&&(c=_cs.annotation(a,"type")===b.name),c}},/*  utility function: flexible parameter handling  */
$cs.params=function(a,b,c){/*  provide parameter processing hook  */
_cs.hook("ComponentJS:params:"+a+":enter","none",{args:b,spec:c});/*  start with a fresh parameter object  */
var d,e={},f=0,g=0,h={};for(d in c)if(_cs.isown(c,d)&&(/*  process parameter position  */
"undefined"!=typeof c[d].pos&&(h[c[d].pos]=d,"number"==typeof c[d].pos&&f++,"undefined"!=typeof c[d].req&&c[d].req&&g++),"undefined"!=typeof c[d].def)){if("undefined"!=typeof c[d].valid&&!$cs.validate(c[d].def,c[d].valid))throw _cs.exception(a,'parameter "'+d+'" has default value '+_cs.json(c[d].def)+', which does not validate against validation specification "'+c[d].valid+'"');e[d]=c[d].def}/*  determine or at least guess whether we were called with
            positional or name-based parameters  */
var i=!1;if(1===b.length&&"object"===_cs.istypeof(b[0])){/*  ok, looks like a regular call like
                "foo({ foo: ..., bar: ...})"  */
i=!0;/*  ...but do not be mislead by a positional use like
                "foo(bar)" where "bar" is an arbitrary object!  */
for(d in b[0])_cs.isown(b[0],d)&&"undefined"==typeof c[d]&&(i=!1)}/*  common value validity checking  */
var j,k,l=function(a,b,c,d){if("undefined"!=typeof d&&!$cs.validate(c,d))throw _cs.exception(a,'parameter "'+b+'" has value '+_cs.json(c)+', which does not validate against "'+d+'"')};if(i){/*  case 1: name-based parameter specification  */
k=b[0];for(d in k)if(_cs.isown(k,d)){if("undefined"==typeof c[d])throw _cs.exception(a,'unknown parameter "'+d+'"');l(a,d,k[d],c[d].valid),e[d]=k[d]}for(d in c)if(_cs.isown(c,d)&&"undefined"!=typeof c[d].req&&c[d].req&&"undefined"==typeof k[d])throw _cs.exception(a,'required parameter "'+d+'" missing')}else{/*  case 2: positional parameter specification  */
if(b.length<g)throw _cs.exception(a,"invalid number of arguments (at least "+g+" required)");for(j=0;j<f&&j<b.length;j++)l(a,h[j],b[j],c[h[j]].valid),e[h[j]]=b[j];if(j<b.length){if("undefined"==typeof h["..."])throw _cs.exception(a,"too many arguments provided");for(k=[];j<b.length;j++)k.push(b[j]);l(a,h["..."],k,c[h["..."]].valid),e[h["..."]]=k}}/*  return prepared parameter object  */
/*  provide parameter processing hook  */
return _cs.hook("ComponentJS:params:"+a+":leave","none",{args:b,spec:c,params:e}),e},/*  Base16 encoding (number)  */
_cs.base16_number=function(a,b,c){var d="";"undefined"==typeof b&&(b=0),"undefined"==typeof c&&(c=!1);for(var e=c?"0123456789ABCDEF":"0123456789abcdef";a>0||b>0;)d=e.charAt(Math.floor(a%16))+d,a=Math.floor(a/16),b>0&&b--;return d},/*  advanced: 128-bit Counter-ID generation  */
_cs.cid=function(){/*  128-bit emulated via 4 x 32-bit JavaScript 64-bit-floating-point-based "number"  */
var a=[0,0,0,0],b=4294967296;/* = 2^32 */
/*  generate the next Counter-ID  */
return function(){/*  increase counter  */
a[3]++;for(var c=0,d=3;d>=0;d--)c+=a[d],a[d]=Math.floor(c%b),c=Math.floor(c/b);/*  return counter  */
return _cs.base16_number(a[0],8,!0)+_cs.base16_number(a[1],8,!0)+_cs.base16_number(a[2],8,!0)+_cs.base16_number(a[3],8,!0)}}(),/*  for passing a function as a callback parameter,
        wrap the function into a proxy function which
        has a particular excecution scope. Also supports
        optional cloning which allows to carry a private
        context which will be cloned together with function  */
_cs.proxy=function(a,b,c){/*  support plain method name  */
"string"===_cs.istypeof(b)&&"object"===_cs.istypeof(a)&&"function"===_cs.istypeof(a[b])&&(b=a[b]),/*  fallback for clonable parameter  */
_cs.isdefined(c)||(c=!1);/*  define the generator  */
var d=function(){/*  generate new wrapper function  */
var e=function(){/*  just pass execution through to wrapped function
                    with our attached store as its execution context object  */
/*  if context is an object, annotate it with
                    the real "this" pointer of this method call  */
return"object"===_cs.istypeof(arguments.callee.__ctx__)&&(arguments.callee.__ctx__.__this__=this),b.apply(arguments.callee.__ctx__,arguments)};/*  return the new wrapper function  */
/*  create the attached store object
                (either with fresh or cloned context)  */
/*  add ourself as the cloning function  */
/*  set "guid" property to the same of original function,
                so it is garbage collected correctly  */
return e.__ctx__=c?_cs.clone(_cs.isdefined(this.__ctx__)?this.__ctx__:a):a,c&&(e.clone=d),e.guid=b.guid=b.guid||e.guid||_cs.cid(),e};/*  run the generator once  */
return d.call({})},/*  generate a proxy function which memoizes/caches the result of an
        idempotent function (a function without side-effects which always
        returns the same output value on the same input parameters)  */
_cs.memoize=function(a){var b=function(){var b,c=_cs.json(_cs.slice(arguments,0));/*  take memoized/cached value  */
/*  calculate new value and memoize/cache it  */
return b=void 0,"undefined"!=typeof arguments.callee.cache[c]?b=arguments.callee.cache[c]:(b=a.apply(this,arguments),arguments.callee.cache[c]=b),b};return b.cache={},b},/*  generate a proxy function which uses "currying"
        to remember its initially supplied arguments  */
_cs.curry=function(a){var b=_cs.slice(arguments,1);return function(){var c=_cs.slice(arguments,0),d=_cs.concat(b,c);return a.apply(this,d)}},/*  for defining getter/setter style attributes  */
$cs.attribute=function(){/*  determine parameters  */
var a=$cs.params("attribute",arguments,{name:{pos:0,req:!0,valid:"string"},def:{pos:1,req:!0,valid:"any"},valid:{pos:2,def:void 0,valid:"(function|RegExp|string)"}});/*  return closure-based getter/setter method  */
return _cs.proxy({value:a.def},function(b){/*  remember old value  */
var c=this.value;/*  act on new value if given  */
if(arguments.length>0){/*  check whether new value is valid  */
if("undefined"!=typeof a.valid&&!$cs.validate(b,a.valid))throw _cs.exception("attribute",'invalid value "'+b+'" for attribute "'+a.name+'"');/*  set new value  */
this.value=b;/*  optionally notify observers  */
var d=this.__this__;"undefined"!=typeof d&&"function"==typeof d.notify&&d.notify.call(d,"attribute:set:"+a.name,b,c,a.name)}/*  return old value  */
return c},!0)},/*  internal hook registry  */
_cs.hooks={},/*  internal hook processing  */
_cs.hook_proc={none:{init:void 0,step:function(){}},pass:{init:function(a){return a[0]},step:function(a,b){return b}},or:{init:!1,step:function(a,b){return a||b}},and:{init:!0,step:function(a,b){return a&&b}},mult:{init:1,step:function(a,b){return a*b}},add:{init:0,step:function(a,b){return a+b}},append:{init:"",step:function(a,b){return a+b}},push:{init:[],step:function(a,b){return a.push(b),a}},concat:{init:[],step:function(a,b){return _cs.concat(a,b)}},insert:{init:{},step:function(a,b){return a[b]=!0,a}},extend:{init:{},step:function(a,b){return _cs.extend(a,b)}}},/*  latch into internal ComponentJS hook  */
_cs.latch=function(a,b){/*  sanity check arguments  */
if(arguments.length<2)throw _cs.exception("latch(internal)","missing arguments");/*  on-the-fly create hook callback registry  */
"undefined"==typeof _cs.hooks[a]&&(_cs.hooks[a]=[]);/*  store callback in hook callback registry  */
var c=_cs.slice(arguments,2),d=_cs.cid();return _cs.hooks[a].push({id:d,cb:b,args:c}),d},/*  unlatch from internal ComponentJS hook  */
_cs.unlatch=function(a,b){/*  sanity check arguments  */
if(2!==arguments.length)throw _cs.exception("unlatch(internal)","invalid number of arguments");if("undefined"==typeof _cs.hooks[a])throw _cs.exception("unlatch(internal)","no such hook");for(var c=-1,d=0;d<_cs.hooks[a].length;d++)if(_cs.hooks[a][d].id===b){c=d;break}if(c===-1)throw _cs.exception("unlatch(internal)","no such latched callback");/*  remove callback from hook callback registry  */
_cs.hooks[a]=_cs.hooks[a].splice(c,1)},/*  provide internal ComponentJS hook  */
_cs.hook=function(a,b){/*  sanity check arguments  */
if(arguments.length<2)throw _cs.exception("hook(internal)","missing argument");if("undefined"==typeof _cs.hook_proc[b])throw _cs.exception("hook(internal)","no such result processing defined");/*  start result with the initial value  */
var c=_cs.hook_proc[b].init,d=null;/*  return the final result  */
/*  give all registered callbacks a chance to
            execute and modify the current result  */
return"function"==typeof c&&(d=_cs.slice(arguments,2),c=c.call(null,d)),"undefined"!=typeof _cs.hooks[a]&&(null===d&&(d=_cs.slice(arguments,2)),_cs.foreach(_cs.hooks[a],function(e){/*  call latched callback  */
var f=e.cb.apply({args:e.args,/*  latch arguments  */
result:c,/*  current result   */
hooks:_cs.hooks[a].length,/*  total number of hooks latched  */
_cs:_cs,/*  internal ComponentJS API  */
$cs:$cs},d);/*  hook arguments  */
/*  process/merge results  */
c=_cs.hook_proc[b].step.call(null,c,f)})),c},/*  API function: select an arbitrary value via a path specification
        and either get the current value or set the new value  */
$cs.select=function(a,b,c){/*  compile path specification (or use pre-compiled path)  */
var d="string"==typeof b?_cs.select_parse(b):b;/*  subset the object graph  */
return 2===arguments.length?_cs.select_path(a,d):_cs.select_path(a,d,c)},/*  the internal compile cache  */
_cs.select_cache={},/*  compile a path specification into array of dereferencing steps  */
_cs.select_parse=function(a){var b=_cs.select_cache[a];if("undefined"==typeof b){b=[];for(var c,d=0,e=a;""!==e;){if(null!==(c=e.match(/^\s*(?:\.)?\s*([a-zA-Z$0-9_][a-zA-Z$0-9_:-]*)/)))b.push(c[1]);else if(null!==(c=e.match(/^\s*\[\s*(\d+|\*{1,2})\s*\]/)))b.push(c[1]);else if(null!==(c=e.match(/^\s*\[\s*"((?:\\"|.)*?)"\s*\]/)))b.push(c[1].replace(/\\"/g,'"'));else{if(null===(c=e.match(/^\s*\[\s*'((?:\\'|.)*?)'\s*\]/))){if(null!==(c=e.match(/^\s+$/)))break;throw _cs.exception("select","parse error: invalid character at: "+a.substr(0,d)+"<"+e.substr(0,1)+">"+e.substr(1))}b.push(c[1].replace(/\\'/g,"'"))}d+=c[0].length,e=e.substr(c[0].length)}_cs.select_cache[a]=b}return b},/*  subset an object graph  */
_cs.select_path=function(a,b){/*  handle special case of empty path */
if(0===b.length){if(3===arguments.length)throw _cs.exception("select","cannot set value on empty path");return a}for(/*  step into object graph according to path prefix  */
var c=0;c<b.length-1;){if("object"!=typeof a)throw _cs.exception("select","cannot further dereference: no more intermediate objects in path");a=a[b[c++]]}/*  get the old value  */
if("object"!=typeof a)throw _cs.exception("select","cannot further dereference: no object at end of path");var d=a[b[c]];/*  optionally set new value  */
if(3===arguments.length){var e=arguments[2];void 0===e?/*  delete value from collection  */
a instanceof Array?a.splice(parseInt(b[c],10),1):delete a[b[c]]:/*  set value into collection  */
a[b[c]]=e}return d},/*
    **  CLASS SYSTEM
    */
/*  utility function: define a JavaScript "class"  */
_cs.clazz_or_trait=function(a,b){/*
         *  STEP 1: CREATE NEW CLASS
         */
/*  create technical class constructor  */
var c=function(){/*  remember information  */
var a=this,b=arguments.callee,c=arguments;/*  support also calls like "foo()" instead of "new foo()"  */
if(!(a instanceof b))return new b;/* RECURSION */
/*  initialize all mixin traits and this class (or trait)  */
var d=function(a,b,c,d){/*  depth-first visit of parent class  */
var e=_cs.annotation(b,"extend");null!==e&&arguments.callee(a,e,c,!1);/* RECURSION */
/*  depth-first visit of mixin traits  */
var f=_cs.annotation(b,"mixin");if(null!==f)for(var g=0;g<f.length;g++)arguments.callee(a,f[g],c,!0);/* RECURSION */
/*  establish clones of all own dynamic fields  */
var h=_cs.annotation(b,"dynamics");if(null!==h)for(var i in h)_cs.isown(h,i)&&("null"!==_cs.istypeof(h[i])&&"function"===_cs.istypeof(h[i].clone)?a[i]=h[i].clone():a[i]=_cs.clone(h[i]));/*  explicitly call optional constructor function
                    NOTICE: a clazz gets supplied the original constructor
                    parameters (we assume that it knows what to do with
                    all or at least the N initial parameters as it is a
                    real parent/base/super class) and has to call its own
                    parent/base/super constructor itself via this.base(),
                    but a trait intentionally gets no constructor parameters
                    passed-through (as it cannot know where it gets mixed
                    into, so it cannot know what to do with the parameters)  */
if(d){var j=_cs.annotation(b,"cons");null!==j&&("clazz"===_cs.istypeof(b)?j.apply(a,c):j.call(a))}};return d(a,b,c,!0),a},d=function(a){return!a.match("^(?:base|__ComponentJS_[A-Za-z]+__)$")};if(_cs.isdefined(a.extend)){/*  inherit all static fields  */
_cs.extend(c,a.extend,d);/*  set the prototype chain to inherit from parent class,
                but WITHOUT calling the parent class's constructor function  */
var e=function(){this.constructor=c};e.prototype=a.extend.prototype,c.prototype=new e,/*  remember parent class  */
_cs.annotation(c,"extend",a.extend)}/*
         *  STEP 3: EXTEND CLASS WITH OWN PROPERTIES AND METHODS
         */
/*  internal utility method for determining whether a given object
            defines a field that matches a state function  */
var f=function(a,b){var c=!0;if("function"===_cs.istypeof(_cs.state_methods)){var d=_cs.state_methods(),e=[];for(var f in b)_cs.isown(b,f)&&d[f]&&(c=!1,e.push('"'+f+'"'));if(!c)throw _cs.exception("clazz_or_trait",'definition of "'+a+'" failed. You can not redefine state transition functions named '+e.join(", "))}return c};_cs.isdefined(a.statics)&&f("statics",a.statics)&&_cs.extend(c,a.statics),_cs.isdefined(a.protos)&&_cs.mixin(c.prototype,a.protos);/*
         *  STEP 4: OPTIONALLY EXPLICITLY INHERIT FROM MIXIN CLASSES
         */
/*  internal utility method for determining whether a function
            exists somewhere in the inheritance chain  */
var g=function(a,b){var c=_cs.annotation(b,"extend");return null!==c&&("clazz"===_cs.istypeof(c)&&("function"===_cs.istypeof(c[a])||"object"===_cs.istypeof(c.prototype)&&"function"===_cs.istypeof(c.prototype[a])||g(a,c)))};if(_cs.isdefined(a.mixin)){/*  inherit from mixin classes  */
for(var h=0;h<a.mixin.length;h++){/*  inherit all static fields  */
_cs.extend(c,a.mixin[h],d);/*  as methods in mixin classes (traits) always have to call "this.base()",
                    because they do not know where they are mixed into, we have to ensure
                    that there is a target for "this.base()". If there is either a non-function
                    (even undefined) property in the class we mixin into or the property
                    is not our own one (and hence coming through the prototype chain),
                    we provide a fallback no-operation function as the base function.  */
for(var i in a.mixin[h].prototype)if(_cs.isown(a.mixin[h].prototype,i)&&("function"!==_cs.istypeof(c.prototype[i])||!_cs.isown(c.prototype,i))){var j;/*  provide a trampoline function  */
j=g(i,c)?function(){return this.base.apply(this,arguments)}:function(){},_cs.annotation(j,"name",i),c.prototype[i]=j}/*  inherit prototype methods  */
_cs.mixin(c.prototype,a.mixin[h].prototype,d)}/*  remember mixin classes  */
_cs.annotation(c,"mixin",a.mixin)}/*
         *  STEP 5: REMEMBER INFORMATION
         */
/*  remember user-supplied constructor function
            (and provide fallback implementation)  */
var k=_cs.nop;_cs.isdefined(a.cons)?k=a.cons:_cs.isdefined(a.extend)&&(k=function(){this.base()}),_cs.annotation(c,"cons",k),/*  provide name for underlying implementation of "base()" for constructor  */
_cs.annotation(k,"name","cons"),_cs.isdefined(a.extend)&&_cs.annotation(k,"base",_cs.annotation(a.extend,"cons")),/*  remember user-supplied setup function  */
_cs.isdefined(a.setup)&&_cs.annotation(c,"setup",a.setup),/*  remember dynamics for per-object initialization  */
_cs.isdefined(a.dynamics)&&f("dynamics",a.dynamics)&&_cs.annotation(c,"dynamics",a.dynamics);/*
         *  STEP 6: PROVIDE BASE/SUPER/PARENT RESOLVING FUNCTIONALITY
         */
/*  internal utility method for resolving an annotation on a
            possibly cloned function (just for the following "base" method).
            Notice: for a cloned function the clone is a wrapper annotated
            with the annotation "clone" set to "true"!  */
var l=function(a,b){for(var c=_cs.annotation(a,b);null===c&&_cs.annotation(a.caller,"clone")===!0;)c=_cs.annotation(a.caller,b),a=a.caller;return c},m=function(a,b,c){/*  determine inheritance of current class  */
var d=_cs.annotation(b,"extend");if(null===d)return null;/*  find function in current class' prototype and mixin chain  */
var e=!1;if("function"===_cs.istypeof(b.prototype[a])&&_cs.isown(b.prototype,a))for(var f=b.prototype[a];"function"===_cs.istypeof(f);){if(f===c){e=!0;break}f=l(f,"base")}/*  if not found, search recusively in the parent hierarchy,
                starting from the parent class  */
/*  if not found, search recusively in the parent hierarchy,
                starting from the parent class  */
return e?d:m(a,d,c)},n=function(a){if(null===_cs.annotation(a,"clone"))for(;_cs.annotation(a.caller,"clone")===!0;)a=a.caller;return a};/*
         *  STEP 7: ALLOW TRAITS TO POST-ADJUST/SETUP DEFINED CLASS
         */
/*  only classes execute trait setups...  */
if(/*  explicitly add "base()" utility method for calling
            the base/super/parent function in the inheritance/mixin chain  */
c.prototype.base=function(){/*  NOTICE: arguments.callee are we just ourself (this function), while
                        arguments.callee.caller is the function calling this.base()!
                        and because our cs.clone() creates wrapper functions we
                        optionally have to take those into account during resolving, too!  */
var a=l(arguments.callee.caller,"name"),b=l(arguments.callee.caller,"base"),c=m(a,this.constructor,n(arguments.callee.caller));/*  attempt 1: call base/super/parent function in mixin chain  */
if("function"===_cs.istypeof(b))return b.apply(this,arguments);if("string"===_cs.istypeof(a)&&"clazz"===_cs.istypeof(c)&&"function"===_cs.istypeof(c[a]))return c[a].apply(this,arguments);if("string"===_cs.istypeof(a)&&"clazz"===_cs.istypeof(c)&&"object"===_cs.istypeof(c.prototype)&&"function"===_cs.istypeof(c.prototype[a]))return c.prototype[a].apply(this,arguments);throw _cs.exception("base",'no base method found for method "'+a+'" in inheritance/mixin chain')},b){var o=function(a,b){/*  depth-first traversal  */
if("array"===_cs.istypeof(_cs.annotation(b,"mixin")))for(var c=_cs.annotation(b,"mixin"),d=0;d<c.length;d++)arguments.callee(a,c[d]);/*  execute optionally existing setup function  */
"function"===_cs.istypeof(_cs.annotation(b,"setup"))&&_cs.annotation(b,"setup").call(a)};o(c,c)}/*  return created class  */
/*
         *  STEP 8: PROVIDE RESULTS
         */
/*  optionally insert class into global namespace ourself  */
return"string"==typeof a.name&&$cs.ns(a.name,c),c},/*  API function: define a usual JavaScript "class"  */
$cs.clazz=function(){/*  determine parameters  */
var a=$cs.params("clazz",arguments,{name:{def:void 0,valid:"string"},extend:{def:void 0,valid:"clazz"},mixin:{def:void 0,valid:"[ trait* ]"},cons:{def:void 0,valid:"function"},statics:{def:void 0,valid:"object"},dynamics:{def:void 0,valid:"object"},protos:{def:void 0,valid:"{ @?: function }"}}),b=_cs.clazz_or_trait(a,!0);/*  return created class  */
/*  mark object as a logical ComponentJS "class"  */
return _cs.annotation(b,"type","clazz"),b},/*  API function: define a Scala-inspired "trait"  */
$cs.trait=function(){/*  determine parameters  */
var a=$cs.params("trait",arguments,{name:{def:void 0,valid:"string"},mixin:{def:void 0,valid:"[ trait* ]"},cons:{def:void 0,valid:"function"},setup:{def:void 0,valid:"function"},statics:{def:void 0,valid:"object"},dynamics:{def:void 0,valid:"object"},protos:{def:void 0,valid:"{ @?: function }"}}),b=_cs.clazz_or_trait(a,!1);/*  return created trait  */
/*  mark object as a logical ComponentJS "trait"  */
return _cs.annotation(b,"type","trait"),b},/*
    **  GENERIC PATTERN TRAITS
    */
/*  generic pattern: id  */
$cs.pattern.id=$cs.trait({dynamics:{id:$cs.attribute("id",null)}}),/*  generic pattern: name  */
$cs.pattern.name=$cs.trait({dynamics:{name:$cs.attribute("name","")}}),/*  generic pattern: tree  */
$cs.pattern.tree=$cs.trait({mixin:[$cs.pattern.name],dynamics:{parent:$cs.attribute("parent",null),children:$cs.attribute("children",[])},protos:{/*  method: path to (and including) node as either object array or name string  */
path:function(a){var b,c;if("undefined"==typeof a)for(/*  return path as object array  */
b=[],c=this;null!==c;c=c.parent())b.push(c);else if(/*  return path as name string  */
b="",null===this.parent())b=a;else for(c=this;null!==c.parent();c=c.parent())b=a+c.name()+b;return b},/*  method: attach node to tree  */
attach:function(a){null!==this.parent()&&this.detach();var b=a.children();b.push(this),a.children(b),this.parent(a)},/*  method: detach node from tree  */
detach:function(){if(null!==this.parent()){var a=this;this.parent().children(_cs.filter(this.parent().children(),function(b){return b!==a})),this.parent(null)}},/*  method: walk tree up  */
walk_up:function(a,b){var c,d;for(c=0,d=this;null!==d;d=d.parent(),c++)b=a(c,d,b);return b},/*  method: walk tree downward */
walk_down:function(a,b){var c=function(b,d,e){"function"==typeof a&&(e=a(b,d,e,!1));for(var f=d.children(),g=0;g<f.length;g++)e=c(b+1,f[g],e);return"function"==typeof a&&(e=a(b,d,e,!0)),e};return b=c(0,this,b)},/*  method: dump tree as indented string representation  */
_tree_dump:function(a){return this.walk_down(function(b,c,d,e){if(!e){for(var f=0;f<b;f++)d+="    ";d+='"'+c.name()+'"',"function"==typeof a&&(d+=": "+a(c)),d+="\n"}return d},"")}}}),/*  generic pattern: configuration  */
$cs.pattern.config=$cs.trait({dynamics:{/*  attributes  */
__config:{}},protos:{/*  method: get/set particular configuration item  */
cfg:function(a,b){var c;if(0===arguments.length){/*  return list of keys  */
c=[];for(var d in this.__config)_cs.isown(this.__config,d)&&c.push(d)}else if(1===arguments.length&&"string"==typeof a)/*  retrieve value  */
c=this.__config[a];else if(2===arguments.length&&null!==b)/*  set value  */
c=this.__config[a],this.__config[a]=b;else{if(2!==arguments.length)throw _cs.exception("cfg","invalid arguments");/*  remove key/value pair  */
c=this.__config[a],delete this.__config[a]}return c}}}),/*  generic pattern: spool  */
$cs.pattern.spool=$cs.trait({dynamics:{/*  attributes  */
__spool:{}},protos:{/*  spool an action for grouped execution  */
spool:function(){/*  determine parameters  */
var a=$cs.params("spool",arguments,{name:{pos:0,req:!0},ctx:{pos:1,req:!0},func:{pos:2,req:!0},args:{pos:"...",def:[]}});/*  sanity check parameters  */
if(!_cs.istypeof(a.func).match(/^(string|function)$/))throw _cs.exception("spool","invalid function parameter (neither function object nor method name)");if("string"===_cs.istypeof(a.func)){if("function"!==_cs.istypeof(a.ctx[a.func]))throw _cs.exception("spool",'invalid method name: "'+a.func+'"');a.func=a.ctx[a.func]}/*  spool cleanup action  */
_cs.isdefined(this.__spool[a.name])||(this.__spool[a.name]=[]),this.__spool[a.name].push(a)},/*  return number of actions which are spooled  */
spooled:function(){/*  determine parameters  */
var a=$cs.params("spooled",arguments,{name:{pos:0,req:!0}});/*  return number of actions which are spooled  */
return _cs.isdefined(this.__spool[a.name])?this.__spool[a.name].length:0},/*  execute spooled actions  */
unspool:function(){/*  determine parameters  */
var a=$cs.params("unspool",arguments,{name:{pos:0,req:!0}}),b=this.__spool[a.name];if(!_cs.isdefined(b))throw _cs.exception("unspool",'no such spool: "'+a.name+'"');for(var c=b.length-1;c>=0;c--)b[c].func.apply(b[c].ctx,b[c].args);/*  destroy spool of now executed cleanup actions  */
delete this.__spool[a.name]}}}),/*  internal utility function: split "[path:]name"
        specification into a component object and a spool name  */
_cs.spool_spec_parse=function(a,b){var c={};c.comp=a,c.name=b;var d=c.name.match(/^([^:]+):(.+)$/);return null!==d&&(c.comp=$cs(a,d[1]),c.name=d[2]),c},/*  generic pattern: tree property  */
$cs.pattern.property=$cs.trait({mixin:[$cs.pattern.tree,$cs.pattern.config],protos:{/*  get/set a property  */
property:function(){/*  determine parameters  */
var a=$cs.params("property",arguments,{name:{pos:0,req:!0},value:{pos:1,def:void 0},def:{def:void 0},scope:{def:void 0},bubbling:{def:!0},targeting:{def:!0},returnowner:{def:!1}});/*  sanity check usage  */
if(!a.targeting&&!a.bubbling)throw _cs.exception("property","disabling both targeting and bubbling makes no sense");/*  start resolving with the default value  */
var b;b=a.def;for(var c,d=[],e=this;null!==e;d.unshift(e.name()),e=e.parent())/*  optionally skip the target component
                        (usually if a property on the parent components
                        should be resolved only, but the scoping for the
                        target component should be still taken into account
                        on the parent) */
if(0!==d.length||a.targeting){/*  first try: child-scoped property  */
if(d.length>0){for(var f=d.length-1;f>=0;f--){var g=d.slice(0,f+1).join("/");if(c=e.cfg("ComponentJS:property:"+a.name+"@"+g),"undefined"!=typeof c)break}if("undefined"!=typeof c){b=a.returnowner?e:c;break}}if(/*  second try: unscoped property  */
c=e.cfg("ComponentJS:property:"+a.name),"undefined"!=typeof c){b=a.returnowner?e:c;break}/*  if we should not bubble, stop immediately  */
if(!a.bubbling)break}/*  return result (either the old configuration
                    value or the owning component)  */
/*  optionally set new configuration value
                    (on current node only)  */
return"undefined"!=typeof a.value&&("undefined"!=typeof a.scope?this.cfg("ComponentJS:property:"+a.name+"@"+a.scope,a.value):this.cfg("ComponentJS:property:"+a.name,a.value)),b}}}),/*  generic pattern: specification  */
$cs.pattern.spec=$cs.trait({mixin:[/*  name-based identification (mandatory)  */
$cs.pattern.name],dynamics:{/*  key/value-based specification (optional)  */
__spec:{}},protos:{/*  method: configure specification  */
spec:function(){var a=this.__spec;if(0===arguments.length)return a;if(1===arguments.length&&"string"==typeof arguments[0])return a[arguments[0]];for(var b=0;b<arguments.length;b++)if("string"==typeof arguments[b])a[arguments[b]]=arguments[b+1],b++;else if("object"==typeof arguments[b])for(var c in arguments[b])_cs.isown(arguments[b],c)&&(a[c]=arguments[b][c])},/*  method: determine whether this object matches the name/spec patterns  */
matches:function(a,b){/*  step 1: match mandatory name  */
if("string"==typeof a){if(this.name()!==a)return!1}else{if(!("object"==typeof a&&a instanceof RegExp))throw _cs.exception("matches","invalid name pattern");if(!this.name().match(a))return!1}/*  step 2: match optional specification  */
var c=this.__spec;for(var d in b)if(_cs.isown(b,d)){if(!_cs.isdefined(c[d]))return!1;var e=b[d];switch(typeof c[d]){case"number":case"boolean":if(c[d]!==e)return!1;break;case"string":if(!("string"==typeof e&&c[d]===e||"object"==typeof e&&e instanceof RegExp&&!c[d].match(e)))return!1}}return!0}}}),/*  generic pattern: observable  */
$cs.pattern.observable=$cs.trait({dynamics:{/*  internal state  */
__listener:{}},protos:{/*  attach a listener  */
listen:function(){/*  determine parameters  */
var a=$cs.params("listen",arguments,{name:{pos:0,req:!0},ctx:{def:this},func:{pos:1,req:!0},args:{pos:"...",def:[]},spec:{def:null}}),b=_cs.cid();return this.__listener[b]=a,b},/*  check for an attached listener  */
listening:function(){/*  determine parameters  */
var a=$cs.params("listening",arguments,{id:{pos:0,req:!0}});/*  check whether listener is attached  */
return"undefined"!=typeof this.__listener[a.id]},/*  detach a listener  */
unlisten:function(){/*  determine parameters  */
var a=$cs.params("unlisten",arguments,{id:{pos:0,req:!0}});/*  detach parameters from component  */
if("undefined"==typeof this.__listener[a.id])throw _cs.exception("unlisten","listener not found");var b=this.__listener[a.id];return delete this.__listener[a.id],b},/*  notify all listeners  */
notify:function(){/*  determine parameters  */
var a=$cs.params("notify",arguments,{name:{pos:0,req:!0},args:{pos:"...",def:[]},matches:{def:function(a,b){return a.name===b.name}}});/*  notify all listeners  */
for(var b in this.__listener)if(_cs.isown(this.__listener,b)){var c=this.__listener[b];if(a.matches(a,c)){var d=_cs.concat(c.args,a.args);c.func.apply(c.ctx,d)}}}}}),/*  generic pattern: event  */
$cs.pattern.event=$cs.clazz({mixin:[$cs.pattern.spec],dynamics:{/*  attributes  */
target:$cs.attribute("target",null),/*  target object the event is send to  */
propagation:$cs.attribute("propagation",!0),/*  whether event propagation should continue  */
processing:$cs.attribute("processing",!0),/*  whether final default event processing should be performed  */
dispatched:$cs.attribute("dispatched",!1),/*  whether event was dispatched at least once to a subscriber  */
decline:$cs.attribute("decline",!1),/*  whether event was declined by subscriber  */
state:$cs.attribute("state","targeting"),/*  state of dispatching: capturing, targeting, spreading, bubbling */
result:$cs.attribute("result",void 0),/*  optional result value event subscribers can provide  */
async:$cs.attribute("async",!1)}}),/*  event factory  */
$cs.event=function(){/*  determine parameters  */
var a=$cs.params("event",arguments,{name:{pos:0,req:!0},spec:{def:{}},target:{pos:1,req:!0},propagation:{pos:2,def:!0},processing:{pos:3,def:!0},dispatched:{pos:4,def:!1},decline:{pos:5,def:!1},state:{pos:6,def:"targeting"},result:{pos:7,def:void 0},async:{pos:8,def:!1}}),b=new $cs.pattern.event;/*  configure event  */
return b.name(a.name),b.target(a.target),b.propagation(a.propagation),b.processing(a.processing),b.dispatched(a.dispatched),b.decline(a.decline),b.state(a.state),b.result(a.result),b.spec(a.spec),b.async(a.async),b},/*  generic pattern: eventing  */
$cs.pattern.eventing=$cs.trait({dynamics:{__subscription:{}},protos:{/*  subscribe on an event  */
subscribe:function(){/*  determine parameters  */
var a=$cs.params("subscribe",arguments,{name:{pos:0,req:!0},spec:{def:{}},ctx:{def:this},func:{pos:1,req:!0},args:{pos:"...",def:[]},capturing:{def:!1},spreading:{def:!1},bubbling:{def:!0},noevent:{def:!1},exclusive:{def:!1},spool:{def:null}}),b=this._subscriptions(a.name.toString(),a.spec);if(1===b.length&&b[0].exclusive)throw _cs.exception("subscribe","existing exclusive subscription prevents additional one");if(a.exclusive&&b.length>0)throw _cs.exception("subscribe","non-exclusive subscription(s) prevent exclusive one");/*  attach parameters to component  */
var c=_cs.cid();/*  optionally spool reverse operation  */
if(this.__subscription[c]=a,null!==a.spool){var d=_cs.spool_spec_parse(this,a.spool);d.comp.spool(d.name,this,"unsubscribe",c)}return c},/*  unsubscribe from an event  */
unsubscribe:function(){/*  determine parameters  */
var a=$cs.params("unsubscribe",arguments,{id:{pos:0,req:!0}});/*  detach parameters from component  */
if("undefined"==typeof this.__subscription[a.id])throw _cs.exception("unsubscribe","subscription not found");delete this.__subscription[a.id]},/*  determine subscription existence  */
_subscription:function(){/*  determine parameters  */
var a=$cs.params("_subscription",arguments,{id:{pos:0,req:!0},details:{pos:1,def:!1}}),b="undefined"!=typeof this.__subscription[a.id];/*  optionally provide details about subscription  */
return a.details&&(b=b?this.__subscription[a.id]:void 0),b},/*  determine subscriptions (internal)  */
_subscriptions:function(){/*  determine parameters  */
var a=$cs.params("_subscriptions",arguments,{name:{pos:0,req:!0},spec:{pos:1,def:{}}}),b=$cs.event({name:a.name,spec:a.spec,target:_cs.nop}),c=[];for(var d in this.__subscription)if(_cs.isown(this.__subscription,d)){var e=this.__subscription[d];b.matches(e.name,e.spec)&&c.push(e)}return c},/*  publish an event */
publish:function(){var a,b=this,c=$cs.params("publish",arguments,{name:{pos:0,req:!0},spec:{def:{}},async:{def:!1},capturing:{def:!0},spreading:{def:!1},bubbling:{def:!0},completed:{def:_cs.nop},resultinit:{def:void 0},resultstep:{def:function(a,b){return b}},directresult:{def:!1},noresult:{def:!1},firstonly:{def:!1},silent:{def:!1},args:{pos:"...",def:[]}}),d=!1;if(!c.capturing&&!c.spreading&&!c.bubbling){var e=!1;for(var f in this.__subscription)if(_cs.isown(this.__subscription,f)){e=!0;break}if(!e){if(c.noresult)return;if(c.directresult)return c.resultinit;d=!0}}/*  create event  */
var g=$cs.event({name:c.name,spec:c.spec,async:c.async,result:c.resultinit,target:b,propagation:!0,processing:!0,dispatched:!1});/*  short-circuit processing (2/2)  */
if(d)return g;/*  tracing  */
c.silent||$cs.debug(1,"event: "+g.target().path("/")+": publish: name="+g.name()+" async="+g.async()+" capturing="+c.capturing+" spreading="+c.spreading+" bubbling="+c.bubbling+" directresult="+c.directresult+" noresult="+c.noresult+" firstonly="+c.firstonly);/*  helper function for dispatching event to single component  */
var h=function(a,b,c,d){for(var e in b.__subscription)if(_cs.isown(b.__subscription,e)){var f=b.__subscription[e];if(("capturing"===d&&f.capturing||"targeting"===d||"spreading"===d&&f.spreading||"bubbling"===d&&f.bubbling)&&a.matches(f.name,f.spec)){/*  verbosity  */
c.silent||$cs.debug(1,"event: "+b.path("/")+": dispatch "+a.name()+" to subscriber on "+d),/*  further annotate event object  */
a.state(d),a.decline(!1);/*  call subscription method  */
var g=_cs.concat(f.noevent?[]:[a],f.args,c.args),h=f.func.apply(f.ctx,g);/*  process return value  */
f.noevent&&_cs.isdefined(h)&&a.result(c.resultstep(a.result(),h)),/*  control the further dispatching  */
a.decline()||(a.dispatched(!0),c.firstonly&&a.propagation(!1))}}},i=function(b,c,d){/*  determine component tree path  */
var e;/*  phase 1: CAPTURING
                        optionally dispatch event downwards from root component
                        towards target component for capturing subscribers  */
if((d.capturing||d.bubbling)&&(e=c.path()),d.capturing)for(a=e.length-1;a>=1&&(h(b,e[a],d,"capturing"),b.propagation());a--);/*  phase 3: SPREADING
                        dispatch event to all descendant components  */
if(/*  phase 2: TARGETING
                        dispatch event to target component  */
b.propagation()&&h(b,c,d,"targeting"),d.spreading&&b.propagation()){var f=function(a,c){var e=!0;if(c||(/*  dispatch on non-target component  */
h(b,a,d,"spreading"),b.propagation()||(/*  if propagation should stop, reset the flag again
                                        as in the spreading phase propagation stops only(!)
                                        for the particular sub-tree, not the propagation
                                        process as a whole!  */
b.propagation(!0),e=!1)),e)for(var g=a.children(),i=0;i<g.length;i++)f(g[i],!1)};f(c,!0)}/*  phase 4: BUBBLING
                        dispatch event upwards from target component towards
                        root component for bubbling (regular) subscribers  */
if(d.bubbling&&b.propagation())for(a=1;a<e.length&&(h(b,e[a],d,"bubbling"),b.propagation());a++);/*  notify publisher on dispatch completion  */
d.completed.call(c,b)};/*  return the event, directly the result value or no result value at all  */
/*  perform event publishing,
                    either asynchronous or synchronous  */
/* global setTimeout:false */
/*  return the event, directly the result value or no result value at all  */
return g.async()?setTimeout(_cs.hook("ComponentJS:settimeout:func","pass",function(){i(g,b,c)}),0):i(g,b,c),c.noresult?void 0:c.directresult?g.result():g}}}),/*  generic pattern: command  */
$cs.pattern.command=$cs.clazz({mixin:[$cs.pattern.observable],dynamics:{/*  standard attributes  */
ctx:$cs.attribute("ctx",null),func:$cs.attribute("func",_cs.nop),args:$cs.attribute("args",[]),async:$cs.attribute("async",!1),/*  usually observed attribute  */
enabled:$cs.attribute("enabled",!0,"boolean")},protos:{/*  method: execute the command  */
execute:function(a,b){if(this.enabled()){var c=[];return this.async()&&c.push(function(a){"function"==typeof b&&b(a)}),c=_cs.concat(c,this.args(),a),this.func().apply(this.ctx(),c)}}}}),/*  command factory  */
$cs.command=function(){/*  determine parameters  */
var a=$cs.params("command",arguments,{ctx:{def:null},func:{pos:0,req:!0},args:{pos:"...",def:[]},async:{def:!1},enabled:{def:!0},wrap:{def:!1}}),b=new $cs.pattern.command;/*  configure command  */
b.ctx(a.ctx),b.func(a.func),b.args(a.args),b.async(a.async),b.enabled(a.enabled);/*  optionally wrap into convenient "execute" closure  */
var c=b;return a.wrap&&(c=function(){var a=_cs.concat(arguments),b=null;return arguments.callee.command.async()&&(b=a.pop()),arguments.callee.command.execute.call(arguments.callee.command,a,b)},c.command=b),c},/*  component states  */
_cs.states=[{/* component is not existing (bootstrapping state transitions only) */
enter:null,leave:null,state:"dead",color:"#000000"}],/*  clear all state transitions (except for "dead" state)  */
_cs.states_clear=function(){_cs.states=_cs.slice(_cs.states,0,1)},/*  add a state transition  */
_cs.states_add=function(a,b,c,d,e){for(/*  create new state configuration  */
var f={enter:b,leave:c,state:a,color:d},g=1;g<_cs.states.length&&(null===e||_cs.states[g].state!==e);)g++;/*  store state  */
_cs.states.splice(g,0,f)},/*  determine all state methods  */
_cs.state_methods=function(){var a,b={};for(a=0;a<_cs.states.length;a++)_cs.states[a].enter&&(b[_cs.states[a].enter]=_cs.states[a]),_cs.states[a].leave&&(b[_cs.states[a].leave]=_cs.states[a]);return b},/*  determine state index via state name  */
_cs.state_name2idx=function(a){var b,c=-1;for(b=0;b<_cs.states.length;b++)if(_cs.states[b].state===a){c=b;break}return c},/*  perform a state enter/leave method call  */
_cs.state_method_call=function(a,b,c){var d=!0,e=b.obj();if(null!==e&&"function"==typeof e[c]){var f={type:a,comp:b,method:c,ctx:e,func:e[c]};_cs.hook("ComponentJS:state-method-call","none",f),d=f.func.call(f.ctx)}return d},/*  set of current state transition requests
        (modeled via a map to the components)  */
_cs.state_requests={},/*  spawn all progression runs (asynchronously)  */
_cs.state_progression=function(){/* global setTimeout:false */
setTimeout(_cs.hook("ComponentJS:settimeout:func","pass",function(){/*  try to process the transition requests  */
var a=[];for(var b in _cs.state_requests)if(_cs.isown(_cs.state_requests,b)){var c=_cs.state_requests[b];_cs.state_progression_single(c)&&a.push(b)}/*  perform deferred removal of original fields  */
_cs.foreach(a,function(a){delete _cs.state_requests[a]}),/*  give plugins a chance to react  */
_cs.hook("ComponentJS:state-change","none")}),0)},/*  execute single progression run  */
_cs.state_progression_single=function(a){var b=!1;return _cs.state_progression_run(a.comp,a.state),_cs.states[a.comp.__state].state===a.state&&("function"==typeof a.callback&&a.callback.call(a.comp,a.state),b=!0),b},/*  perform a single synchronous progression run for a particular component  */
_cs.state_progression_run=function(a,b,c){var d,e,f,g,h,i;/*  handle optional argument (USED INTERNALLY ONLY)  */
"undefined"==typeof c&&(c="upward-and-downward");/*  determine index of state by name  */
var j=_cs.state_name2idx(b);if(j===-1)throw _cs.exception("state",'invalid argument "'+b+'"');/*  perform upward/downward state transition(s)  */
if(a.__state<j)/*  transition to higher state  */
for(;a.__state<j;){/*  mandatory transition parent component to higher state first  */
if(/*  determine names of state and enter method  */
f=_cs.states[a.__state+1].state,g=_cs.states[a.__state+1].enter,null!==a.parent()&&a.parent().state_compare(f)<0&&(_cs.state_progression_run(a.parent(),f,"upward"),a.parent().state_compare(f)<0))return void $cs.debug(1,"state: "+a.path("/")+": transition (increase) REJECTED BY PARENT COMPONENT ("+a.parent().path("/")+"): @"+_cs.states[a.__state].state+" --("+g+")--> @"+_cs.states[a.__state+1].state+": SUSPENDING CURRENT TRANSITION RUN");/*  transition current component to higher state second  */
if(_cs.isdefined(a.__state_guards[g]))return void $cs.debug(1,"state: "+a.path("/")+": transition (increase) REJECTED BY ENTER GUARD: @"+_cs.states[a.__state].state+" --("+g+")--> @"+_cs.states[a.__state+1].state+": SUSPENDING CURRENT TRANSITION RUN");/*  execute enter method  */
if(a.__state++,$cs.debug(1,"state: "+a.path("/")+": transition (increase): @"+_cs.states[a.__state-1].state+" --("+g+")--> @"+_cs.states[a.__state].state),_cs.hook("ComponentJS:state-invalidate","none","states"),_cs.hook("ComponentJS:state-change","none"),_cs.state_method_call("enter",a,g)===!1)/*  FULL STOP: state enter method rejected state transition  */
return $cs.debug(1,"state: "+a.path("/")+": transition (increase) REJECTED BY ENTER METHOD: @"+_cs.states[a.__state-1].state+" --("+g+")--> @"+_cs.states[a.__state].state+": SUSPENDING CURRENT TRANSITION RUN"),void a.__state--;/*  optionally automatically transition
                    child component(s) to higher state third  */
if(/*  notify subscribers about new state  */
a.publish({name:"ComponentJS:state:"+_cs.states[a.__state].state+":enter",noresult:!0,capturing:!1,spreading:!1,bubbling:!1,async:!0,silent:!0}),/*  give plugins a chance to react  */
_cs.hook("ComponentJS:state-enter","none",a,_cs.states[a.__state].state),"upward-and-downward"===c||"downward"===c)for(e=a.children(),d=0;d<e.length;d++)e[d].state_compare(f)<0&&(e[d].state_auto_increase()||e[d].property("ComponentJS:state-auto-increase")===!0)&&(_cs.state_progression_run(e[d],f,"downward"),/*  RECURSION  */
e[d].state_compare(f)<0&&(/*  enqueue state transition for child  */
_cs.state_requests[e[d].id()]={comp:e[d],state:f},_cs.hook("ComponentJS:state-invalidate","none","requests"),_cs.hook("ComponentJS:state-change","none")))}else if(a.__state>j)/*  transition to lower state  */
for(;a.__state>j;){/*  determine names of state and leave method  */
f=_cs.states[a.__state].state,h=_cs.states[a.__state].leave;var k=_cs.states[a.__state-1].state;for(/*  mandatory transition children component(s) to lower state first  */
e=a.children(),d=0;d<e.length;d++)if(e[d].state_compare(k)>0&&(_cs.state_progression_run(e[d],k,"downward"),e[d].state_compare(k)>0))return void $cs.debug(1,"state: "+a.path("/")+": transition (decrease) REJECTED BY CHILD COMPONENT ("+e[d].path("/")+"): @"+_cs.states[a.__state-1].state+" <--("+h+")-- @"+_cs.states[a.__state].state+": SUSPENDING CURRENT TRANSITION RUN");/*  transition current component to lower state second  */
if(_cs.isdefined(a.__state_guards[h]))return void $cs.debug(1,"state: "+a.path("/")+": transition (decrease) REJECTED BY LEAVE GUARD: @"+_cs.states[a.__state-1].state+" <--("+h+")-- @"+_cs.states[a.__state].state+": SUSPENDING CURRENT TRANSITION RUN");/*  execute leave method  */
if(a.__state--,$cs.debug(1,"state: "+a.path("/")+": transition (decrease): @"+_cs.states[a.__state].state+" <--("+h+")-- @"+_cs.states[a.__state+1].state),_cs.hook("ComponentJS:state-invalidate","none","states"),_cs.hook("ComponentJS:state-change","none"),_cs.state_method_call("leave",a,h)===!1)/*  FULL STOP: state leave method rejected state transition  */
return $cs.debug(1,"state: "+a.path("/")+": transition (decrease) REJECTED BY LEAVE METHOD: @"+_cs.states[a.__state].state+" <--("+h+")-- @"+_cs.states[a.__state+1].state+": SUSPENDING CURRENT TRANSITION RUN"),void a.__state++;/*  in case leave method successful or not present
                        automatically unspool still pending actions
                        on spool named exactly like the left state  */
i=a.spooled(f),i>0&&($cs.debug(1,"state: "+a.path("/")+": auto-unspooling "+i+" operation(s)"),a.unspool(f)),/*  notify subscribers about new state  */
a.publish({name:"ComponentJS:state:"+_cs.states[a.__state+1].state+":leave",noresult:!0,capturing:!1,spreading:!1,bubbling:!1,async:!0,silent:!0}),/*  give plugins a chance to react  */
_cs.hook("ComponentJS:state-leave","none",a,_cs.states[a.__state+1].state),/*  optionally automatically transition
                    parent component to lower state third  */
"upward-and-downward"!==c&&"upward"!==c||null!==a.parent()&&a.parent().state_compare(k)>0&&(a.parent().state_auto_decrease()||a.parent().property("ComponentJS:state-auto-decrease")===!0)&&(_cs.state_progression_run(a.parent(),k,"upward"),/*  RECURSION  */
a.parent().state_compare(k)>0&&(/*  enqueue state transition for parent  */
_cs.state_requests[a.parent().id()]={comp:a.parent(),state:k},_cs.hook("ComponentJS:state-invalidate","none","requests"),_cs.hook("ComponentJS:state-change","none")))}},/*  generic pattern for state management  */
$cs.pattern.state=$cs.trait({mixin:[$cs.pattern.tree],dynamics:{/*  attributes  */
__state:0,/* = dead */
__state_guards:{},state_auto_increase:$cs.attribute("state_auto_increase",!1),state_auto_decrease:$cs.attribute("state_auto_decrease",!1)},protos:{/*  get state or set state (or at least trigger transition)  */
state:function(){/*  special case: just retrieve current state  */
var a=_cs.states[this.__state].state;if(0===arguments.length)return a;/*  determine parameters  */
var b=$cs.params("state",arguments,{state:{pos:0,req:!0,valid:function(a){return _cs.state_name2idx(a)!==-1}},func:{pos:1,def:void 0},min:{def:void 0},max:{def:void 0},sync:{def:!1}}),c=this.__state,d=_cs.state_name2idx(b.state);if(b.min===!0&&!b.max&&d>c||!b.min&&b.max===!0&&d<c||b.min===!0&&b.max===!0&&d!==c||!b.min&&!b.max&&d!==c){var e=!0,f={comp:this,state:b.state,callback:b.func};b.sync&&_cs.state_progression_single(f)&&(e=!1),e&&(/*  enqueue new state transition request and trigger
                            state transition progression (asynchronously)  */
_cs.state_requests[this.id()]=f,_cs.hook("ComponentJS:state-invalidate","none","requests"),_cs.state_progression())}else/*  still run its optional callback function  */
"function"==typeof b.func&&b.func.call(this,b.state);/*  return old (and perhaps still current) state  */
return a},/*  compare state of component  */
state_compare:function(){/*  determine parameters  */
var a=$cs.params("state",arguments,{state:{pos:0,req:!0,valid:function(a){return _cs.state_name2idx(a)!==-1}}}),b=_cs.state_name2idx(a.state);/*  compare given state against state of component  */
return this.__state-b},/*  guard a state enter/leave method  */
guard:function(){/*  determine parameters  */
var a,b=$cs.params("guard",arguments,{method:{pos:0,valid:"string",req:!0},level:{pos:1,valid:"number",req:!0}}),c=!1;for(a=0;a<_cs.states.length;a++)if(_cs.states[a].enter===b.method||_cs.states[a].leave===b.method){c=!0;break}if(!c)throw _cs.exception("guard",'no such declared enter/leave method: "'+b.method+'"');/*  ensure the guard slot exists  */
_cs.isdefined(this.__state_guards[b.method])||(this.__state_guards[b.method]=0);/*  activate/deactivate guard  */
var d=!1;if(b.level>0)/*  increase guard level  */
this.__state_guards[b.method]+=b.level;else if(b.level<0){/*  decrease guard level  */
if(this.__state_guards[b.method]<-b.level)throw _cs.exception("guard","guard level decrease request too large");this.__state_guards[b.method]+=b.level,0===this.__state_guards[b.method]&&(d=!0)}else/*  reset guard level  */
this.__state_guards[b.method]=0,d=!0;d&&(/*  finally deactivate guard  */
delete this.__state_guards[b.method],/*  give all pending state transitions
                        (which now might proceed) a chance  */
_cs.state_progression())}}}),/*  generic pattern: service  */
$cs.pattern.service=$cs.trait({mixin:[$cs.pattern.eventing],protos:{/*  register a service  */
register:function(){/*  determine parameters  */
var a=$cs.params("register",arguments,{name:{pos:0,req:!0},ctx:{def:this},func:{pos:1,req:!0},args:{pos:"...",def:[]},spool:{def:null},capturing:{def:!1},spreading:{def:!1},bubbling:{def:!0}}),b=$cs.command({ctx:a.ctx,func:a.func,args:a.args,wrap:!0});/*  publish changes to command's callable status  */
b.command.listen({name:"attribute:set:enabled",args:[this,a.name],func:function(a,b,c,d){a.publish({name:"ComponentJS:service:"+b+":callable",args:[c,d],capturing:!1,spreading:!1,bubbling:!1,async:!0,noresult:!0})}});/*  subscribe to service event  */
var c=this.subscribe({name:"ComponentJS:service:"+a.name,ctx:a.ctx,func:b,noevent:!0,capturing:a.capturing,spreading:a.spreading,bubbling:a.bubbling,exclusive:!0});/*  optionally spool reverse operation  */
if(null!==a.spool){var d=_cs.spool_spec_parse(this,a.spool);d.comp.spool(d.name,this,"unregister",c)}return c},/*  unregister a service  */
unregister:function(){/*  determine parameters  */
var a=$cs.params("unregister",arguments,{id:{pos:0,req:!0}});/*  unsubscribe from service event  */
this.unsubscribe(a.id)},/*  make a service callable (enable/disable it)  */
callable:function(){/*  determine parameters  */
var a=$cs.params("callable",arguments,{name:{pos:0,req:!0},value:{pos:1,def:void 0}}),b=this._subscriptions(a.name);if(1===b.length){var c=b[0].func().command;/*  get or set "enabled" attribute  */
return c.enabled(a.value)}},/*  call a service  */
call:function(){/*  determine parameters  */
var a=$cs.params("call",arguments,{name:{pos:0,req:!0},args:{pos:"...",def:[]},capturing:{def:!1},spreading:{def:!1},bubbling:{def:!0}}),b=this.publish({name:"ComponentJS:service:"+a.name,args:a.args,capturing:a.capturing,spreading:a.spreading,bubbling:a.bubbling,firstonly:!0,async:!1});/*  ensure that the service event was successfully dispatched
                    at least once (or our result value would have no meaning)  */
if(!b.dispatched())throw _cs.exception("call",'no such registered service found: "'+a.name+'"');/*  return the result value  */
return b.result()}}}),/*  generic pattern: backing object  */
$cs.pattern.backing=$cs.trait({dynamics:{__obj:null},protos:{/*  get/set corresponding object  */
obj:function(a){if("undefined"==typeof a)/*  get current object  */
return this.__obj;if("object"!=typeof a)throw _cs.exception("obj","invalid argument");/*  set new object  */
return null!==a?(_cs.annotation(a,"comp",this),this.__obj=a):(null!==this.__obj&&_cs.annotation(this.__obj,"comp",null),this.__obj=null),this},/*  get/set attribute in corresponding object  */
access:function(a,b){/*  sanity check scenario  */
if("undefined"==typeof a)throw _cs.exception("access","no attribute name given");var c=this.obj();if(null===c)throw _cs.exception("access","still no object attached");if("undefined"==typeof c[a])throw _cs.exception("access",'invalid attribute "'+a+'"');/*  access the attribute  */
var d=c[a];return"undefined"!=typeof b&&(c[a]=b),d},/*  invoke method on corresponding object  */
invoke:function(a){/*  sanity check scenario  */
if("undefined"==typeof a)throw _cs.exception("invoke","no method name given");var b=this.obj();if(null===b)throw _cs.exception("invoke","still no object attached");if("undefined"==typeof b[a])throw _cs.exception("invoke",'invalid method "'+a+'"');if("function"!==_cs.istypeof(b[a]))throw _cs.exception("invoke",'anything named "'+a+'" existing, but not a function');/*  call method  */
var c=_cs.slice(arguments,1);return b[a].apply(b,c)}}}),/*  generic pattern: socket  */
$cs.pattern.socket=$cs.trait({mixin:[$cs.pattern.tree,$cs.pattern.property],dynamics:{__sockets:{},__plugs:{}},protos:{/*  define a socket  */
socket:function(){/*  determine parameters  */
var a=$cs.params("socket",arguments,{name:{def:"default"},scope:{def:null},ctx:{pos:0,req:!0},plug:{pos:1,req:!0},unplug:{pos:2,req:!0},spool:{def:null}});/*  sanity check parameters  */
if("string"===_cs.istypeof(a.plug)&&"function"!==_cs.istypeof(a.ctx[a.plug]))throw _cs.exception("socket",'no plug method named "'+a.plug+'" found on context object');if("string"!==_cs.istypeof(a.plug)&&"function"!==_cs.istypeof(a.plug))throw _cs.exception("socket","plug operation neither method name nor function");if("string"===_cs.istypeof(a.unplug)&&"function"!==_cs.istypeof(a.ctx[a.unplug]))throw _cs.exception("socket",'no unplug method named "'+a.unplug+'" found on context object');if("string"!==_cs.istypeof(a.unplug)&&"function"!==_cs.istypeof(a.unplug))throw _cs.exception("socket","unplug operation neither method name nor function");/*  remember parameters as (optionally scoped) component property  */
var b="ComponentJS:socket:"+a.name;null!==a.scope&&(b+="@"+a.scope),$cs(this).property(b,a);/*  remember socket under an id  */
var c=_cs.cid();/*  optionally spool reverse operation  */
if(this.__sockets[c]=b,null!==a.spool){var d=_cs.spool_spec_parse(this,a.spool);d.comp.spool(d.name,this,"unsocket",c)}return c},/*  destroy a socket  */
unsocket:function(){/*  determine parameters  */
var a=$cs.params("unsocket",arguments,{id:{pos:0,req:!0}});/*  remove  parameters from component  */
if("undefined"==typeof this.__sockets[a.id])throw _cs.exception("unsocket","socket not found");/*  remove corresponding property  */
var b=this.__sockets[a.id];$cs(this).property(b,null),/*  remove socket information  */
delete this.__sockets[a.id]},/*  create a linking/pass-through socket  */
link:function(){/*  determine parameters  */
var a=$cs.params("link",arguments,{name:{def:"default"},scope:{def:null},target:{pos:0,req:!0},socket:{pos:1,req:!0},spool:{def:null}});/*  create a socket and pass-through the
                    plug/unplug operations to the target  */
return this.socket({name:a.name,scope:a.scope,spool:a.spool,ctx:{},plug:function(b){var c=_cs.annotation(b,"link");if(null!==c)throw _cs.exception("link:plug: cannot plug, you have to unplug first");c=$cs(a.target).plug({name:a.socket,object:b,targeting:!0}),_cs.annotation(b,"link",c)},unplug:function(b){var c=_cs.annotation(b,"link");if(null===c)throw _cs.exception("link:unplug: cannot unplug, you have to plug first");$cs(a.target).unplug({id:c,targeting:!0}),_cs.annotation(b,"link",null)}})},/*  destroy a link  */
unlink:function(){/*  determine parameters  */
var a=$cs.params("unlink",arguments,{id:{pos:0,req:!0}});return this.unsocket(a.id)},/*  plug into a defined socket  */
plug:function(){/*  determine parameters  */
var a=$cs.params("plug",arguments,{name:{def:"default"},object:{pos:0,req:!0},spool:{def:null},targeting:{def:!1}}),b=_cs.cid();/*  optionally spool reverse operation  */
if(this.__plugs[b]=a,/*  pass-through operation to common helper function  */
_cs.plugger("plug",this,a.name,a.object,a.targeting),null!==a.spool){var c=_cs.spool_spec_parse(this,a.spool);c.comp.spool(c.name,this,"unplug",b)}return b},/*  unplug from a defined socket  */
unplug:function(){/*  determine parameters  */
var a=$cs.params("unplug",arguments,{id:{pos:0,req:!0},targeting:{def:!1}});/*  determine plugging information  */
if("undefined"==typeof this.__plugs[a.id])throw _cs.exception("unplug","plugging not found");var b=this.__plugs[a.id].name,c=this.__plugs[a.id].object;/*  pass-though operation to common helper function  */
_cs.plugger("unplug",this,b,c,a.targeting),/*  remove plugging  */
delete this.__plugs[a.id]}}}),/*  internal "plug/unplug to socket" helper functionality  */
_cs.plugger=function(a,b,c,d,e){/*  resolve the socket property on the parents components
            NOTICE 1: we explicitly skip the origin component here as
                      resolving the socket property also on the origin
                      component might otherwise return the potentially existing
                      socket for the child components of the orgin component.
            NOTICE 2: we intentionally skip the origin and do not directly
                      resolve on the parent component as we want to take
                      scoped sockets (on the parent component) into account!  */
var f="ComponentJS:socket:"+c,g=b.property({name:f,targeting:e});if(!_cs.isdefined(g))throw _cs.exception(a,"no socket found on parent component(s)");/*  determine the actual component owning the socket (for logging purposes only)  */
var h=b.property({name:f,targeting:e,returnowner:!0});/*  perform plug/unplug operation  */
if($cs.debug(1,"socket: "+h.path("/")+": "+c+" <--("+a+")-- "+b.path("/")),"string"===_cs.istypeof(g[a]))g.ctx[g[a]].call(g.ctx,d,b);else{if("function"!==_cs.istypeof(g[a]))throw _cs.exception(a,'failed to perform "'+a+'" operation');g[a].call(g.ctx,d,b)}},/*  utility function: mark a component  */
$cs.mark=function(a,b){var c=_cs.annotation(a,"marker");null===c&&(c={}),c[b]=!0,_cs.annotation(a,"marker",c)},/*  utility function: determine whether a component is marked  */
$cs.marked=function(a,b){var c=_cs.annotation(a,"marker");return null===c&&(c={}),c[b]===!0},/*  generic pattern for marking components  */
$cs.pattern.marker=$cs.trait({protos:{mark:function(a){$cs.mark(this.obj(),a)},marked:function(a){return $cs.marked(this.obj(),a)}}}),/*  convenient marker traits  */
$cs.marker={service:$cs.trait({cons:function(){$cs.mark(this,"service")}}),controller:$cs.trait({cons:function(){$cs.mark(this,"controller")}}),model:$cs.trait({cons:function(){$cs.mark(this,"model")}}),view:$cs.trait({cons:function(){$cs.mark(this,"view")}})},/*  load store via optional plugin  */
_cs.store_load=function(a){null===a.__store&&(_cs.hook("ComponentJS:store-load","none",a),null!==a.__store&&"object"==typeof a.__store||(a.__store={}))},/*  save store via optional plugin  */
_cs.store_save=function(a){null!==a.__store&&_cs.hook("ComponentJS:store-save","none",a)},/*  generic pattern for store management  */
$cs.pattern.store=$cs.trait({dynamics:{__store:null},protos:{store:function(){var a,b;if(0===arguments.length){/*  get all keys  */
_cs.store_load(this);var c=[];for(a in this.__store)c.push(a);return c}if(1===arguments.length&&null===arguments[0])/*  clear store  */
return this.__store={},_cs.store_save(this),null;if(1===arguments.length&&"string"==typeof arguments[0])/*  get value  */
return _cs.store_load(this),a=arguments[0],"undefined"==typeof this.__store[a]?null:this.__store[a];if(2===arguments.length&&null===arguments[1])/*  delete value  */
return _cs.store_load(this),a=arguments[0],delete this.__store[a],_cs.store_save(this),null;if(2===arguments.length)/*  set value  */
return _cs.store_load(this),a=arguments[0],b=arguments[1],this.__store[a]=b,_cs.store_save(this),b;throw _cs.exception("store","invalid argument(s)")}}}),/*  generic pattern for model management  */
$cs.pattern.model=$cs.trait({protos:{/*  define model  */
model:function(){/*  determine parameters  */
var a=$cs.params("model",arguments,{spec:{pos:0,req:!0,valid:"{ @: { value?: any, valid?: (string|function|RegExp), autoreset?: boolean, store?: boolean} }"}}),b={spec:a.spec,data:{}};_cs.foreach(_cs.keysof(b.spec),function(a){var c=b.spec[a];/*  sanity check model item specification  */
if(/*  provide default values for all the optional model item options  */
"undefined"==typeof c.value&&(c.value=""),"undefined"==typeof c.valid&&(c.valid="string"),"undefined"==typeof c.autoreset&&(c.autoreset=!1),"undefined"==typeof c.store&&(c.store=!1),!$cs.validate(c.value,c.valid))throw _cs.exception("model",'model field "'+a+'" has default value '+_cs.json(c.value)+', which does not validate against validation specification "'+c.valid+'"');/*  take over initial model item value  */
b.data[a]=c.value});/*  optionally load model values from store  */
var c=this.store("model");null!==c&&_cs.foreach(_cs.keysof(b.spec),function(a){b.spec[a].store&&_cs.isdefined(c[a])&&(b.data[a]=c[a])});/*  optionally merge new model into old model  */
var d=this.property({name:"ComponentJS:model",bubbling:!1});if(_cs.isdefined(d)){var e={spec:{},data:{}};_cs.extend(e.spec,d.spec),_cs.extend(e.data,d.data),_cs.extend(e.spec,b.spec),_cs.extend(e.data,b.data),b=e}/*  optionally save model values to store  */
c={};var f=!1;_cs.foreach(_cs.keysof(b.spec),function(a){b.spec[a].store&&(c[a]=b.data[a],f=!0)}),f&&this.store("model",c),/*  (re)attach model to component  */
this.property("ComponentJS:model",b)},/*  get/set model value  */
value:function(){/*  determine parameters  */
var a=$cs.params("value",arguments,{name:{pos:0,req:!0,valid:"string"},value:{pos:1,def:void 0,valid:"any"},force:{pos:2,def:!1,valid:"boolean"},injected:{def:!1,valid:"boolean"},op:{def:[],valid:"(string|[string?]|[string,number,number])"},returnowner:{def:!1,valid:"boolean"}});if(/*  determine operation  */
"string"==typeof a.op&&(a.op=[a.op]),0===a.op.length)a.op=_cs.isdefined(a.value)?["set"]:["get"];else if(!a.op[0].match(/^(?:get|set|splice|delete|push|pop|shift|unshift)$/))throw _cs.exception("value",'invalid operation "'+a.op[0]+'"');if("splice"===a.op[0]&&(3!==a.op.length||"number"!=typeof a.op[1]||"number"!=typeof a.op[2]))throw _cs.exception("value",'invalid arguments for operation "splice"');for(/*  parse the value name into selection path segments  */
var b=_cs.select_parse(a.name),c=b.join("."),d=null,e=null,f=this;null!==f;){if(d=f.property({name:"ComponentJS:model",returnowner:!0}),!_cs.isdefined(d))throw _cs.exception("value",'no model found containing value "'+b[0]+'"');if(e=d.property("ComponentJS:model"),_cs.isdefined(e.spec[b[0]]))break;f=d.parent()}if(null===f)throw _cs.exception("value",'no model found containing value "'+b[0]+'"');/*  get new model value  */
var g,h=a.value;switch(a.op[0]){case"unshift":a.op=["splice",0,0];break;case"shift":a.op=["splice",0,1],h=void 0;break;case"push":g=$cs.select(e.data,b),a.op=["splice",g.length,0];break;case"pop":g=$cs.select(e.data,b),a.op=["splice",g.length-1,1],h=void 0}/*  get old model value  */
var i,j,k=$cs.select(e.data,b);/*  optionally set/delete/splice new model value  */
if("splice"===a.op[0]?/*  splice operation is on collection itself,
                        so pick the target collection element!  */
k=a.op[2]>0?$cs.select(k,""+a.op[1]):void 0:"get"===a.op[0]&&d.property({name:"ComponentJS:model:subscribers:get",def:0,bubbling:!1})>0&&(/*  send event to observers for value get and allow observers
                            to reject value get operation and/or change old value to get  */
i=d.publish({name:"ComponentJS:model:"+c+":"+a.op[0],args:[k,k,a.op,c],capturing:!1,spreading:!1,bubbling:!1,async:!1}),i.processing()&&(/*  allow value to be overridden by event result  */
j=i.result(),"undefined"!=typeof j&&(k=j))),"set"===a.op[0]&&(a.force||k!==h)||"delete"===a.op[0]||"splice"===a.op[0]){/*  check validity of new value  */
if("set"===a.op[0]||"splice"===a.op[0]&&void 0!==h){var l="splice"===a.op[0]?b.slice(1).concat(["0"]):b.slice(1);if(!_cs.validate_at(h,e.spec[b[0]].valid,l))throw _cs.exception("value",'model field "'+a.name+'" receives new value '+_cs.json(h)+', which does not validate against "'+e.spec[b[0]].valid+'"'+(l.length>0?' at sub-path "'+l.join(".")+'"':""))}/*  send event to observers for value set/delete/splice operation
                        and allow observers to reject operation and/or change new value to set  */
var m=!0;if(d.property({name:"ComponentJS:model:subscribers:"+a.op[0],def:0,bubbling:!1})>0)if(i=d.publish({name:"ComponentJS:model:"+c+":"+a.op[0],args:[h,k,a.op,c],capturing:!1,spreading:!1,bubbling:!1,async:!1}),i.processing())/*  allow value to be overridden  */
j=i.result(),"undefined"!=typeof j&&(h=j);else{if(a.injected)throw _cs.exception("value",'model field "'+a.name+'" receives (again) value '+_cs.json(h)+", which is rejected by observers, but the value was indicated to be already injected by third-parties (so it technically no longer can be rejected)");m=!1}if(m&&!e.spec[b[0]].autoreset){/*  perform destructive operation on model  */
if("set"===a.op[0])/*  set value in model  */
$cs.select(e.data,b,h);else if("splice"===a.op[0]){if(/*  splice value into model  */
g=$cs.select(e.data,b),!(g instanceof Array))throw new _cs.exception("value","cannot splice: target object is not of Array type");"undefined"!=typeof h?g.splice(a.op[1],a.op[2],h):g.splice(a.op[1],a.op[2])}else if("delete"===a.op[0]){/*  delete value from model  */
if(b.length<2)throw new _cs.exception("value","cannot delete model root or top-level model entry");g=$cs.select(e.data,b.slice(0,b.length-1));var n=b[b.length-1];if(g instanceof Array)g.splice(parseInt(n,10),1);else{if("object"!=typeof g)throw new _cs.exception("value","cannot delete: target object is neither Array nor Object type");delete g[n]}}/*  synchronize model with underlying store  */
if(e.spec[b[0]].store){var o=d.store("model");o[b[0]]=e.data[b[0]],d.store("model",o)}/*  send event to observers after value finally changed  */
d.property({name:"ComponentJS:model:subscribers:changed",def:0,bubbling:!1})>0&&d.publish({name:"ComponentJS:model:"+c+":changed",args:[h,k,a.op,c],noresult:!0,capturing:!1,spreading:!1,bubbling:!1,async:!0})}}/*  return old model value  */
return a.returnowner?d:k},/*  touch a model value and trigger event  */
touch:function(){/*  determine parameters  */
var a=$cs.params("touch",arguments,{name:{pos:0,req:!0,valid:"string"}});/*  simply force value to same value in order to trigger event  */
this.value({name:a.name,value:this.value(a.name),injected:!0,force:!0})},/*  start observing model value change  */
observe:function(){for(/*  determine parameters  */
var a=$cs.params("observe",arguments,{name:{pos:0,req:!0,valid:"string"},func:{pos:1,req:!0,valid:"function"},touch:{def:!1,valid:"boolean"},boot:{def:!1,valid:"boolean"},op:{def:"set",valid:/^(?:get|set|changed|splice|delete)$/},spool:{def:null,valid:"(null|string)"},noevent:{def:!1,valid:"boolean"}}),b=_cs.select_parse(a.name),c=null,d=null,e=this;null!==e;){if(c=e.property({name:"ComponentJS:model",returnowner:!0}),!_cs.isdefined(c))throw _cs.exception("observe",'no model found containing value "'+b[0]+'"');if(d=c.property("ComponentJS:model"),_cs.isdefined(d.spec[b[0]]))break;e=c.parent()}if(null===e)throw _cs.exception("observe",'no model found containing value "'+b[0]+'"');/*  support wildcard matching and always match childs  */
var f=b.join(".").replace(/\./g,"\\.").replace(/\*\*/g,".+?").replace(/\*/g,"[^.]+");f+="(?:\\.[^.]+)*";/*  subscribe to model value change event  */
var g=c.subscribe({name:new RegExp("ComponentJS:model:"+f+":"+a.op),capturing:!1,spreading:!1,bubbling:!1,noevent:a.noevent,func:a.func}),h="ComponentJS:model:subscribers:"+a.op,i=c.property({name:h,def:0});/*  optionally spool reverse operation  */
if(i+=1,c.property({name:h,value:i}),null!==a.spool){var j=_cs.spool_spec_parse(this,a.spool);j.comp.spool(j.name,this,"unobserve",g)}/*  if requested (for a one-time initial observer run),
                    either touch the model value once (which causes _all_ observers to trigger!)
                    or do a "bootstrapping execution" of only our callback function once  */
if(a.touch)this.touch(a.name);else if(a.boot){var k=this.value(a.name),l=[k,k,a.op,b.join(".")];a.noevent||l.unshift($cs.event({name:a.name,spec:{},async:!1,result:void 0,target:this,propagation:!0,processing:!0,dispatched:!1})),a.func.apply(this,l)}return g},/*  stop observing model value change  */
unobserve:function(){for(/*  determine parameters  */
var a,b=$cs.params("unobserve",arguments,{id:{pos:0,req:!0,valid:"string"}}),c=null,d=this;null!==d;){if(c=d.property({name:"ComponentJS:model",returnowner:!0}),!_cs.isdefined(c))throw _cs.exception("unobserve","no model subscription found");if(void 0!==(a=c._subscription(b.id,!0)))break;d=c.parent()}if(null===d)throw _cs.exception("unobserve","no model subscription found");/*  unsubscribe from model value change event  */
c.unsubscribe(b.id);/*  unmark component for having subscribers of operation  */
var e="ComponentJS:model:subscribers:"+a.op,f=c.property({name:e,def:0});f=f>0?f-1:null,c.property({name:e,value:f})}}}),/*
    **  COMPONENT API
    */
/*  component class definition (placeholder)  */
_cs.comp=null,/*  singleton component instances (placeholder)  */
_cs.none=null,_cs.root=null,/*  component mixins (default)  */
_cs.comp_mixins=[$cs.pattern.id,$cs.pattern.name,$cs.pattern.tree,$cs.pattern.config,$cs.pattern.spool,$cs.pattern.state,$cs.pattern.service,$cs.pattern.eventing,$cs.pattern.property,$cs.pattern.backing,$cs.pattern.socket,$cs.pattern.model,$cs.pattern.store,$cs.pattern.marker],/*  component constructor  */
_cs.comp_cons=function(a,b,c){/*  component marking  */
_cs.annotation(this,"type","component"),"string"!==_cs.istypeof(a)&&(a="<unknown>"),this.name(a),/*  component tree and object attachment  */
this.parent("object"===_cs.istypeof(b)?b:null),this.children("array"===_cs.istypeof(c)?c:[])},/*  component prototype methods  */
_cs.comp_protos={/*  create a sub-component  */
create:function(){return $cs.create.apply(this,_cs.concat([this],arguments))},/*  destroy sub-component (or just this component) */
destroy:function(){return $cs.destroy.apply(this,_cs.concat([this],arguments))},/*  check for existance of a component  */
exists:function(){return"<none>"!==this.name()}},/*  internal bootstrapping flag  */
_cs.bootstrapped=!1,/*  initialize library  */
$cs.bootstrap=function(){/*  sanity check environment  */
if(_cs.bootstrapped)throw _cs.exception("bootstrap","library already bootstrapped");/*  give plugins a chance to modify the component class definition  */
_cs.hook("ComponentJS:bootstrap:comp:mixin","none",_cs.comp_mixins),_cs.hook("ComponentJS:bootstrap:comp:protos","none",_cs.comp_protos),/*  lazy define component class
            (to give plugins a chance to have added mixins)  */
_cs.comp=$cs.clazz({mixin:_cs.comp_mixins,cons:_cs.comp_cons,protos:_cs.comp_protos}),/*  create singleton component: root of the tree */
_cs.root=new _cs.comp("<root>",null,[]),/*  create singleton component: special return value on lookups */
_cs.none=new _cs.comp("<none>",null,[]);/*  reasonable error catching for _cs.none usage
            ATTENTION: method "exists" intentionally is missing here,
                       because it is required to be called on _cs.none, of course!  */
var a=["call","callable","create","destroy","guard","hook","invoke","latch","link","model","observe","plug","property","publish","register","registration","socket","spool","spooled","state","state_compare","store","subscribe","subscription","touch","unlatch","unobserve","unplug","unregister","unspool","unsubscribe","value"];_cs.foreach(a,function(a){_cs.none[a]=function(){throw _cs.exception(a,'no such component (you are calling method "'+a+'" on component "<none>")')}}),/*  give plugins a chance to bootstrap, too  */
_cs.hook("ComponentJS:bootstrap","none"),/*  set new state  */
_cs.bootstrapped=!0},/*  shutdown library  */
$cs.shutdown=function(){/*  sanity check environment  */
if(!_cs.bootstrapped)throw _cs.exception("shutdown","library still not bootstrapped");/*  give plugins a chance to shutdown, too  */
_cs.hook("ComponentJS:shutdown","none"),/*  tear down the whole component tree  */
_cs.foreach(_cs.root.children(),function(a){a.destroy()}),_cs.root.state({state:"dead",sync:!0}),/*  destroy singleton "<none>" component  */
_cs.none=null,/*  destroy singleton "<root>" component  */
_cs.root=null,/*  destroy component class  */
_cs.comp=null,/*  set new state  */
_cs.bootstrapped=!1},/*  lookup component by path  */
_cs.lookup=function(a,b){/*  handle special cases for path in advance  */
if(/*  handle special calling conventions  */
1===arguments.length&&("string"===_cs.istypeof(arguments[0])?(/*  special calling via path only: $cs("foo") -> $cs(_cs.root, "foo") */
b=a,a=_cs.root):/*  special calling via base only: $cs(this) -> $cs(this, "") */
b=""),"string"!=typeof b)return _cs.none;if("<root>"===b)return _cs.root;if("<none>"===b)return _cs.none;/*  bootstrap component matching  */
var c;if("/"===b.substr(0,1))/*  ignore base  */
c=_cs.root,b=b.substring(1);else{/*  use base  */
var d=_cs.istypeof(a),e=_cs.annotation(a,"comp");if("component"!==d&&null!==e)/*  success: found component object via backing object  */
c=e;else{if("component"!==d)/*  failure: found other object which is not already component  */
throw _cs.exception("lookup",'invalid base component (type is "'+d+'")');/*  success: found component object  */
c=a}}if(""!==b){/*  lookup components  */
var f=[];/*  post-process component result set  */
if(_cs.lookup_step(f,c,b.split("/"),0),0===f.length)/*  no component found  */
c=_cs.none;else if(1===f.length)/*  single and hence unambitous component found  */
c=f[0];else{/*  more than one result found: try to reduce duplicates first  */
var g={};if(f=_cs.filter(f,function(a){var b=a.id(),c="undefined"==typeof g[b];return g[b]=!0,c}),1!==f.length){for(var h="",i=0;i<f.length;i++)h+=" "+f[i].path("/");throw _cs.exception("lookup",'ambiguous component path "'+b+'" at '+c.path("/")+": expected only 1 component, but found "+f.length+" components:"+h)}/*  after de-duplication now only a single component found  */
c=f[0]}}/*  return component  */
return c},/*  lookup component(s) at "comp", reachable via path segment "path[i]"  */
_cs.lookup_step=function(a,b,c,d){var e,f,g;if(d>=c.length)/*  stop recursion  */
a.push(b);else if("."===c[d])/*  CASE 1: current component (= no-op)  */
_cs.lookup_step(a,b,c,d+1);else if(".."===c[d])/*  CASE 2: parent component  */
null!==b.parent()&&_cs.lookup_step(a,b.parent(),c,d+1);else if("*"===c[d])for(/*  CASE 3: all child components  */
f=b.children(),e=0;e<f.length;e++)_cs.lookup_step(a,f[e],c,d+1);else if(""===c[d])for(/*  CASE 4: all descendent components  */
g=b.walk_down(function(a,b,c,d){return d||c.push(b),c},[]),e=0;e<g.length;e++)_cs.lookup_step(a,g[e],c,d+1);else for(/*  CASE 5: a specific child component  */
f=b.children(),e=0;e<f.length;e++)if(f[e].name()===c[d]){_cs.lookup_step(a,f[e],c,d+1);/* RECURSION */
break}},/*  top-level API: create one or more components  */
$cs.create=function(){/*  sanity check environment  */
if(!_cs.bootstrapped){/*  give warning but still be backward compatible  */
var a='ComponentJS: WARNING: component system still not bootstrapped (please call "bootstrap" method before first "create" method call!)';/* global alert:false */
/* eslint no-alert: 0 */
"function"==typeof alert?alert(a):"undefined"!=typeof console&&"function"==typeof console.log&&console.log(a),$cs.bootstrap()}/*  sanity check arguments  */
if(arguments.length<2)throw _cs.exception("create","invalid number of arguments");/*  initialize processing state  */
var b=0,c=null,d=null,e=[];/*  determine base component  */
if("string"===_cs.istypeof(arguments[b])){if("/"!==arguments[b].substr(0,1))throw _cs.exception("create",'either base component has to be given or the tree specification has to start with the root component ("/")');c=_cs.root}else if(d=arguments[b++],"component"!==_cs.istypeof(d)&&(d=_cs.annotation(d,"comp"),null===d))throw _cs.exception("create","invalid base argument (not an object attached to a component)");for(/*  tokenize the tree specification  */
var f,g=[],h=arguments[b++];""!==h&&(f=h.match(/^\s*([^\/{},]+|[\/{},])/),null!==f);)g.push(f[1]),h=h.substr(f[1].length);/*  iterate over all tokens...  */
for(var i=function(a,b){for(var c="",d=0;d<b&&d<a.length;d++)c+=a[d];if(d<a.length)for(c+="<",c+=a[d++],c+=">";d<a.length;d++)c+=a[d];return c},j=0;j<g.length;j++)if("/"===g[j]){/*  switch base  */
if(null===c)throw _cs.exception("create","no parent component for step-down at "+i(g,j));d=c}else if("{"===g[j])/*  save base  */
e.push(d);else if(","===g[j]){/*  reset base  */
if(0===e.length)throw _cs.exception("create","no open brace section for parallelism at "+i(g,j));d=e[e.length-1]}else if("}"===g[j]){/*  restore base  */
if(0===e.length)throw _cs.exception("create","no more open brace section for closing at "+i(g,j));d=e.pop(),c=null}else{/*  create new component  */
if(null===d)throw _cs.exception("create","no base component at "+i(g,j));c=_cs.create_single(d,g[j],arguments[b++])}if(e.length>0)throw _cs.exception("create","still open brace sections at end of tree specification");/*  return (last created) component  */
return c},/*  internal: create a single component  */
_cs.create_single=function(a,b,c){/*  sanity check parameters  */
if("string"!=typeof b)throw _cs.exception("create","invalid path argument (not a string)");/*  split path into existing tree and the not existing component leaf node  */
var d=b.match(/^(.*?)\/?([^\/]+)$/);if(!d[0])throw _cs.exception("create",'invalid path "'+b+'"');var e=d[1],f=d[2],g=_cs.cid();/*  substitute special "{id}" constructs in leaf path  */
f=f.replace(/\{id\}/g,g);/*  lookup parent component (has to be existing)  */
var h=_cs.lookup(a,e);if(h===_cs.none)throw _cs.exception("create",'parent component path "'+e+'" not already existing (please create first)');/*  attempt to lookup leaf component (has to be not existing)  */
var i=_cs.lookup(h,f);if(i!==_cs.none)throw _cs.exception("create",'leaf component path "'+f+'" already existing (please destroy first)');/*  instanciate class  */
var j=null;switch(_cs.istypeof(c)){case"clazz":case"trait":case"function":/*  standard case: $cs.create(..., MyClass)
                    ComponentJS clazz/trait or foreign "class"  */
j=new c;break;case"object":/*  special case: $cs.create(..., new MyClass(arg1, arg2))
                    manual instanciation because of parameter passing  */
j=c;break;case"null":/*  special case: $cs.create(..., null)
                    early component create & late object attachment  */
break;default:throw _cs.exception("create","invalid class argument")}/*  switch state from "dead" to the first user-defined state (usually "created")
            (here synchronously as one expects that after a creation of a
            component, the state is really already "created", of course)  */
if(/*  create new corresponding component object in tree  */
i=new _cs.comp(f),/*  mark with component id  */
i.id(g),/*  attach to tree  */
i.attach(h),/*  remember bi-directional relationship between component and object  */
i.obj(j),/*  debug hint  */
$cs.debug(1,"component: "+i.path("/")+": created component ["+i.id()+"]"),/*  give plugins a chance to react (before creation of a component)  */
_cs.hook("ComponentJS:comp-created","none",i),_cs.states.length<=1)throw _cs.exception("create","no user-defined component states");/*  return new component  */
/*  give plugins a chance to react (after creation of a component)  */
return i.state({state:_cs.states[1].state,sync:!0}),_cs.hook("ComponentJS:state-invalidate","none","components"),_cs.hook("ComponentJS:state-change","none"),i},/*  top-level API: destroy a component  */
$cs.destroy=function(){/*  sanity check arguments  */
if(1!==arguments.length&&2!==arguments.length)throw _cs.exception("destroy","invalid number of arguments");/*  determine component  */
var a=_cs.lookup.apply(this,arguments);if(a===_cs.none)throw _cs.exception("destroy","no such component found to destroy");if(a===_cs.root)throw _cs.exception("destroy","root component cannot be destroyed");var b=a.path("/"),c=a.id();/*  switch component state to "dead"
            (here synchronously as one expects that after a destruction of a
            component, the state is really already "dead", of course)  */
a.state({state:"dead",sync:!0}),/*  give plugins a chance to react (before final destruction of a component)  */
_cs.hook("ComponentJS:comp-destroyed","none",a),/*  detach component from component tree  */
a.detach(),/*  remove bi-directional relationship between component and object  */
a.obj(null),/*  debug hint  */
$cs.debug(1,"component: "+b+": destroyed component ["+c+"]"),/*  give plugins a chance to react (after final destruction of a component)  */
_cs.hook("ComponentJS:state-invalidate","none","components"),_cs.hook("ComponentJS:state-change","none")},/*  define a state transition  */
$cs.transition=function(){/*  special case  */
if(1===arguments.length&&null===arguments[0])/*  remove all user-defined transitions  */
return void _cs.states_clear();/*  determine parameters  */
var a=$cs.params("transition",arguments,{target:{pos:0,req:!0},enter:{pos:1,req:!0},leave:{pos:2,req:!0},color:{pos:3,def:"#000000"},source:{def:null}});/*  add new state  */
_cs.states_add(a.target,a.enter,a.leave,a.color,a.source)},/*  initialize state transition set with a reasonable default  */
$cs.transition("created","create","destroy","#cc3333"),/* created and attached to component tree */
$cs.transition("configured","setup","teardown","#eabc43"),/* configured and wired */
$cs.transition("prepared","prepare","cleanup","#f2ec00"),/* prepared and ready for rendering */
$cs.transition("materialized","render","release","#6699cc"),/* rendered onto the DOM tree */
$cs.transition("visible","show","hide","#669933"),/* visible to the user */
$cs.transition("enabled","enable","disable","#336600"),/* enabled for interaction */
/*
    **  GLOBAL LIBRARY EXPORTING
    */
/*  export our global API...  */
"object"==typeof EXPORTS&&"undefined"==typeof GLOBAL.ComponentJS_export||"undefined"!=typeof GLOBAL.ComponentJS_export&&"CommonJS"===GLOBAL.ComponentJS_export?/*  ...to scoped CommonJS environment  */
EXPORTS.ComponentJS=$cs:"function"==typeof DEFINE&&"object"==typeof DEFINE.amd&&"undefined"==typeof GLOBAL.ComponentJS_export||"undefined"!=typeof GLOBAL.ComponentJS_export&&"AMD"===GLOBAL.ComponentJS_export?/*  ...to scoped AMD environment  */
DEFINE("ComponentJS",function(){return $cs}):/*  ...to regular global environment  */
$cs.symbol("ComponentJS"),/*  internal plugin registry  */
_cs.plugins={},/*  external plugin API  */
$cs.plugin=function(a,b){if(0===arguments.length){/*  use case 1: return list of registered plugins  */
var c=[];for(a in _cs.plugins)_cs.isown(_cs.plugins,a)&&c.push(a);return c}if(1===arguments.length){/*  use case 2: check whether particular plugin was registered  */
if("string"!=typeof a)throw _cs.exception("plugin","invalid plugin name parameter");return"undefined"!=typeof _cs.plugins[a]}if(2!==arguments.length)throw _cs.exception("plugin","invalid number of parameters");/*  use case 3: register a new plugin  */
if("string"!=typeof a)throw _cs.exception("plugin","invalid plugin name parameter");if("undefined"!=typeof _cs.plugins[a])throw _cs.exception("plugin",'plugin named "'+a+'" already registered');b.call(this,_cs,$cs,GLOBAL),_cs.plugins[a]=!0}}(/* global window:false */
/* global global:false */
/* global exports:false */
/* global define:false */
"undefined"!=typeof window?window:"undefined"!=typeof global?global:"undefined"!=typeof this?this:{},"object"==typeof exports?exports:void 0,"function"==typeof define?define:void 0);