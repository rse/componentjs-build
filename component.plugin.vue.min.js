/*
**  ComponentJS -- Component System for JavaScript <http://componentjs.com>
**  Copyright (c) 2009-2016 Ralf S. Engelschall <http://engelschall.com>
**
**  This Source Code Form is subject to the terms of the Mozilla Public
**  License (MPL), version 2.0. If a copy of the MPL was not distributed
**  with this file, You can obtain one at http://mozilla.org/MPL/2.0/.
*/
/*
 *  This is a ComponentJS plugin which integrates the awesome Vue
 *  library for view mask rendering and data binding. It provides the
 *  following distinct features:
 *
 *  - It provides a new ComponentJS API method vue() which accepts
 *    a required Vue "options" parameter (also accepted as a first
 *    positional parameter) and an optional "spool" parameter (also
 *    accepted as a second positional parameter). The "options"
 *    parameter is required to have a Vue "template" field with the view
 *    mask as either a string, a DOM fragment or a jQuery DOM fragment.
 *    The result is a rendered but unmounted Vue instance which can
 *    be later plugged into a socket and/or further manipulated (with
 *    jQuery) through its "$el" field.
 *
 *  - It provides a new ComponentJS API method unvue(<vue>) which
 *    accepts a Vue instance (as previously created by the vue() method)
 *    and unplugs and destroys it. Usually this is not required as one
 *    should use the "spool" parameter of vue() to automatically unplug
 *    and destroy the Vue instance.
 *
 *  - For all Vue instances, it generates for all ComponentJS model
 *    values (from the current component, usually a view component,
 *    up to the root component) Vue computed getter/setter fields
 *    (<name>) which perform true bi-directional data-binding. They can
 *    be used like e.g. v-bind:<attr>="<name>" in the view mask. The
 *    ComponentJS model values (by convention) named "eventXXX" are
 *    treated specially: Vue methods of the same name are generated
 *    for them, which can be used like e.g. v-on:click="eventXXX" (for
 *    passing an "Event" instance, which is then converted into "true")
 *    or v-on:click="eventXXX(<arg>)" (for receiving an arbitrary
 *    single argument) in the view mask. The names of ComponentJS
 *    model values are converted into valid Vue symbols by replacing
 *    all [^a-zA-Z0-9_$] characters with "_" characters. Hence it is
 *    recommended to use camel-case ComponentJS model values like
 *    "paramFooBar", "stateFooBar", "dataFooBar", and "eventFooBar"
 *    only.
 *
 *  - For all Vue instances, it generates trampoline methods for all
 *    methods named "utilXXX" in the backing object of the ComponentJS
 *    (view) component. They can be used like v-if="utilXXX(...)" in the
 *    view masks for complex checks or calculations if really necessary.
 *
 *  - For all Vue instances, it creates ComponentJS sockets for all
 *    DOM elements in the Vue template which are tagged as sockets. For
 *    this, all HTML elements with data-socket="[<name>][@<scope>]"
 *    lead to a ComponentJS socket with <name> and <scope>. The default
 *    <name> is "default". The default <scope> is no scope at all.
 *    The "ctx" parameter of ComponentJS socket() is the HTML element
 *    itself.
 *
 *  - It intercepts the ComponentJS socket() method and makes its "plug"
 *    and "unplug" parameters optional instead of required. The provided
 *    fallback "plug" and "unplug" functions now accepts Vue (and
 *    jQuery) instances as returned by the ComponentJS API method vue().
 *    This plugin requires Vue, but jQuery is not directly required.
 */
/* global ComponentJS: false */
/* global Vue: false */
/* global Event: false */
/* eslint no-unused-vars: 0 */
/* jshint unused: false */
/*  helper function for detecting jQuery object  */
var isjQuery=function(a){return"object"==typeof a&&"string"==typeof a.jquery&&null!==a.jquery.match(/^[0-9]+(?:\.[0-9]+)+$/)},isVue=function(a){return"object"==typeof a&&"boolean"==typeof a._isVue&&a._isVue===!0};/*  hook as a plugin into ComponentJS  */
ComponentJS.plugin("vue",function(a,b,c){/*  define the extra trait for components  */
var d=b.trait({protos:{/*  create a new Vue instance  */
vue:function(){/*  determine parameters  */
var c=this,d=b.params("vue",arguments,{options:{pos:0,req:{}},spool:{pos:1,def:null}});/*  prepare the HTML mask template  */
if("undefined"==typeof d.options.template)throw a.exception("vue","missing mandatory Vue template");if(isjQuery(d.options.template)&&(d.options.template=d.options.template.get(0)),"string"==typeof d.options.template){for(;;){var e=d.options.template.replace(/^\s*<!--.*?-->\s*/,"");if(d.options.template===e)break;d.options.template=e}d.options.template=d.options.template.replace(/^\s+/,"").replace(/\s+$/,"")}for(/*  iterate over all models towards the root component and find all model values  */
var f,g,h={},i=this;null!==i&&(f=i.property({name:"ComponentJS:model",returnowner:!0}),a.isdefined(f));){g=f.property("ComponentJS:model"),i=f.parent();/*  remember all model values  */
for(var j in g.data)h[j]=f}var k=Object.keys(h);if(0===k.length)throw a.exception("vue","no models values found at all");/*  prepare Vue options  */
"object"!=typeof d.options.data&&(d.options.data={}),"object"!=typeof d.options.computed&&(d.options.computed={}),"object"!=typeof d.options.methods&&(d.options.methods={});/*  the symbol prefix for ComponentJS trigger model values  */
var l="ComponentJS_trigger_";/*  provide Vue model entries for all ComponentJS model values  */
a.foreach(k,function(a){var e=a.replace(/[^a-zA-Z0-9_$]+/g,"_");e.match(/^event.+$/)?/*  ComponentJS event values "eventXXX" are implemented as Vue methods  */
d.options.methods[e]=function(d){b(c).value(a,"object"==typeof d&&d instanceof Event||d)}:(/*  other ComponentJS values are implemented as Vue computed properties  */
d.options.data[l+e]=0,d.options.computed[e]={get:function(){/*  get the underlying ComponentJS value  */
/*  tell Vue that we are depending on our trigger value
                                    (so we can later force Vue to call us again instead of
                                    using the cached value we returned beforehand)  */
return void this[l+e],b(c).value(a)},set:function(d){/*  update the Vue trigger value to ensure that Vue
                                    is forced to update the cached value of the above getter  */
this[l+e]++,/*  set the underlying ComponentJS value  */
b(c).value(a,d)}})});/*  provide Vue trampoline methods for all ComponentJS
                    view component backing object utility methods "utilXXX"  */
var m=c.obj();if(null!==m)for(var n=a.state_methods(),o=m;null!==o;o=Object.getPrototypeOf(o)){var p=Object.getOwnPropertyNames(o);a.foreach(p,function(a){void 0===n[a]&&"function"==typeof o[a]&&a.match(/^util.+$/)&&(d.options.methods[a]=function(){return m[a].apply(m,arguments)})})}/*  hook into Vue instance life-cycle  */
d.options.beforeDestroy=function(){a.foreach(this.__ComponentJS.observers,function(a){b(c).unobserve(a)}),a.foreach(this.__ComponentJS.sockets,function(a){b(c).unsocket(a)})};/*  create Vue instance  */
var q=new Vue(d.options);/*  render into a still stand-alone DOM fragment  */
q.$mount(),/*  attach ComponentJS information to Vue instance  */
q.__ComponentJS={observers:[],sockets:[]},/*  provide observers for the ComponentJS model values  */
a.foreach(k,function(d){var e=d.replace(/[^a-zA-Z0-9_$]+/g,"_"),f=function(){/*  just update the Vue trigger value  */
q[l+e]++};a.foreach(["set","splice","delete"],function(a){var e=b(c).observe({name:d,op:a,func:f});q.__ComponentJS.observers.push(e)})});for(var r=q.$el.querySelectorAll("*[data-socket]"),s=0;s<r.length;s++){var t=r[s].getAttribute("data-socket"),u="",v=t.match(/^(.*)@(.+)$/);null!==v&&(t=v[1],u=v[2]);var w={ctx:r[s]};""!==t&&(w.name=t),""!==u&&(w.scope=u);var x=b(c).socket(w);q.__ComponentJS.sockets.push(x)}/*  optionally spool Vue instance destruction  */
if(null!==d.spool){var y=a.spool_spec_parse(this,d.spool);y.comp.spool(y.name,this,function(a){a.$destroy()},q)}/*  return Vue model  */
return q},/*  destroy a Vue instance  */
unvue:function(c){/*  determine parameters  */
var d=b.params("unvue",arguments,{vm:{pos:0,req:null}});/*  sanity check parameter  */
if(!isVue(d.vm))throw a.exception("unvue","invalid Vue instance");/*  destroy Vue instance  */
d.vm.$destroy()},/*  override the original ComponentJS socket() API method  */
socket:function(){/*  determine parameters  */
var a=b.params("socket",arguments,{name:{def:"default"},scope:{def:null},ctx:{pos:0,req:!0},plug:{pos:1,def:null},/*  removed "req: true"  */
unplug:{pos:2,def:null},/*  removed "req: true"  */
spool:{def:null}});/*  pass-through execution to original/base method  */
/*  provide specialized socket "plug" functionality  */
/*  provide specialized socket "unplug" functionality  */
return null===a.plug&&(a.plug=function(a){/*  on-the-fly get the HTML element from jQuery/Vue object  */
isjQuery(a)?a=a.get(0):isVue(a)&&(a=a.$el),/*  append to the DOM tree (the jQuery or plain way)  */
isjQuery(this)?this.append(a):this.appendChild(a)}),null===a.unplug&&(a.unplug=function(a){/*  remove from the DOM tree (the jQuery way)  */
if(isjQuery(a))a.detach();else{/*  on-the-fly get the HTML element from Vue object  */
isVue(a)&&(a=a.$el);/*  remove from the DOM tree (the plain way)  */
var b=a.parentElement;null!==b&&b.removeChild(a)}}),this.base(a)}}});/*  mixin this trait to all components  */
a.latch("ComponentJS:bootstrap:comp:mixin",function(a){a.push(d)})});